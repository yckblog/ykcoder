<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="–iOS多媒体 概览 随着移动互联网的发展，如今的手机早已不是打电话、发短信那么简单了，播放音乐、视频、录音、拍照等都是很常用的功能。在iOS中对于多媒体的支持是非常强大的，无论是音视频播放、录制，还是对麦克风、摄像头的操作都提供了多套API。在今天的文章中将会对这些内容进行一一介绍：  音频   音效  音乐  音频会话  录音  音频队列服务  视频   MPMoviePlayerContro">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发之音视频播放录制">
<meta property="og:url" content="http://yoursite.com/2015/09/02/iOS开发之音视频播放录制/index.html">
<meta property="og:site_name" content="YKcoder">
<meta property="og:description" content="–iOS多媒体 概览 随着移动互联网的发展，如今的手机早已不是打电话、发短信那么简单了，播放音乐、视频、录音、拍照等都是很常用的功能。在iOS中对于多媒体的支持是非常强大的，无论是音视频播放、录制，还是对麦克风、摄像头的操作都提供了多套API。在今天的文章中将会对这些内容进行一一介绍：  音频   音效  音乐  音频会话  录音  音频队列服务  视频   MPMoviePlayerContro">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260912573583432.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260912592026602.gif">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913004838643.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913018904414.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913041086769.gif">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913054053041.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913083277781.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913098274523.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913120303650.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913366718687.gif">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913394998158.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913408122957.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913418904527.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913454994125.gif">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913466409208.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260913485621122.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260914169997701.gif">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260914290623149.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260914332184945.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260914350306359.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260914412966311.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/62046/201412/260914428126282.png">
<meta property="og:updated_time" content="2016-03-29T11:07:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS开发之音视频播放录制">
<meta name="twitter:description" content="–iOS多媒体 概览 随着移动互联网的发展，如今的手机早已不是打电话、发短信那么简单了，播放音乐、视频、录音、拍照等都是很常用的功能。在iOS中对于多媒体的支持是非常强大的，无论是音视频播放、录制，还是对麦克风、摄像头的操作都提供了多套API。在今天的文章中将会对这些内容进行一一介绍：  音频   音效  音乐  音频会话  录音  音频队列服务  视频   MPMoviePlayerContro">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> iOS开发之音视频播放录制 | YKcoder </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">YKcoder</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">没有代码的日子好孤单！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                iOS开发之音视频播放录制
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-02T19:03:08+08:00" content="2015-09-02">
              2015-09-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/09/02/iOS开发之音视频播放录制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/02/iOS开发之音视频播放录制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p><div id="cnblogs_post_body"><p align="right"><strong>–iOS多媒体</strong></p> <h1>概览</h1> <p>随着移动互联网的发展，如今的手机早已不是打电话、发短信那么简单了，播放音乐、视频、录音、拍照等都是很常用的功能。在iOS中对于多媒体的支持是非常强大的，无论是音视频播放、录制，还是对麦克风、摄像头的操作都提供了多套API。在今天的文章中将会对这些内容进行一一介绍：</p> <ol class="kc-catalog"> <li><a href="#audio">音频</a>  <ol> <li><a href="#soundEffect">音效</a>  </li><li><a href="#music">音乐</a>  </li><li><a href="#audioSession">音频会话</a>  </li><li><a href="#audioRecord">录音</a>  </li><li><a href="#audioQueueServices">音频队列服务</a> </li></ol> </li><li><a href="#video">视频</a>  <ol> <li><a href="#mpMoviePlayerController">MPMoviePlayerController</a>  </li><li><a href="#mpMoviePlayerViewController">MPMoviePlayerViewController</a>  </li><li><a href="#avPlayer">AVPlayer</a> </li></ol> </li><li><a href="#camera">摄像头</a>  <ol> <li><a href="#uiImagePickerController">UIImagePickerController拍照和视频录制</a>  </li><li><a href="#avFoundationCamera">AVFoundation拍照和录制视频</a> </li></ol> </li><li><a href="#summary">总结</a> </li></ol> <h1 id="audio">音频</h1> <p>在iOS中音频播放从形式上可以分为音效播放和音乐播放。前者主要指的是一些短音频播放，通常作为点缀音频，对于这类音频不需要进行进度、循环等控制。后者指的是一些较长的音频，通常是主音频，对于这些音频的播放通常需要进行精确的控制。在iOS中播放两类音频分别使用AudioToolbox.framework和AVFoundation.framework来完成音效和音乐播放。</p> <h2 id="soundEffect">音效</h2> <p>AudioToolbox.framework是一套基于C语言的框架，使用它来播放音效其本质是将短音频注册到系统声音服务（System Sound Service）。System Sound Service是一种简单、底层的声音播放服务，但是它本身也存在着一些限制：</p> <ul> <li>音频播放时间不能超过30s  </li><li>数据必须是PCM或者IMA4格式  </li><li>音频文件必须打包成.caf、.aif、.wav中的一种（注意这是官方文档的说法，实际测试发现一些.mp3也可以播放）</li></ul> <p>使用System Sound Service 播放音效的步骤如下：</p> <ol> <li>调用<strong>AudioServicesCreateSystemSoundID(&nbsp;&nbsp; CFURLRef&nbsp; inFileURL, SystemSoundID<em>&nbsp;&nbsp; outSystemSoundID)</em></strong>函数获得系统声音ID。  </li><li>如果需要监听播放完成操作，则使用<strong>AudioServicesAddSystemSoundCompletion(&nbsp; SystemSoundID inSystemSoundID,<br>CFRunLoopRef&nbsp; inRunLoop, CFStringRef&nbsp; inRunLoopMode, AudioServicesSystemSoundCompletionProc&nbsp; inCompletionRoutine, void&nbsp; inClientData)</strong>方法注册回调函数。  </li><li>调用<strong>AudioServicesPlaySystemSound(SystemSoundID inSystemSoundID) </strong>或者<strong>AudioServicesPlayAlertSound(SystemSoundID inSystemSoundID)</strong> 方法播放音效（后者带有震动效果）。</li></ol> <p>下面是一个简单的示例程序：</p><pre class="code"><span style="background: white; color: green">//<br>//  KCMainViewController.m<br>//  Audio<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//  音效播放</span></pre></div></p>
<p><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“KCMainViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AudioToolbox/AudioToolbox.h&gt;</span></p>
<p><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">KCMainViewController ()</span></p>
<p>@end</p>
<p>@implementation KCMainViewController</p>
<ul>
<li><p>(<span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];</span></p>
<p>  [self playSoundEffect:@<span style="background: white; color: #a31515">“videoRing.caf”</span><span style="background: white; color: black">];<br>}</span></p>
</li>
</ul>
<p><span style="background: white; color: green">/**</span></p>
<ul>
<li>播放完成回调函数<br>*</li>
<li>@param soundID    系统声音ID</li>
<li>@param clientData 回调时传递的数据<br><em>/<br><span style="background: white; color: blue">void </span><span style="background: white; color: black">soundCompleteCallback(SystemSoundID soundID,</span><span style="background: white; color: blue">void </span><span style="background: white; color: black"></span></em> clientData){<br>NSLog(@<span style="background: white; color: #a31515">“播放完成…”</span><span style="background: white; color: black">);<br>}</span></li>
</ul>
<p><span style="background: white; color: green">/**</span></p>
<ul>
<li>播放音效文件<br>*</li>
<li>@param name 音频文件名称<br><em>/<br><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)playSoundEffect:(NSString </span></em>)name{<br>NSString <em>audioFile=[[NSBundle mainBundle] pathForResource:name ofType:nil];<br>NSURL </em>fileUrl=[NSURL fileURLWithPath:audioFile];<br><span style="background: white; color: green">//1.获得系统声音ID<br></span><span style="background: white; color: black">SystemSoundID soundID=0;<br></span><span style="background: white; color: green">/**<ul>
<li>inFileUrl:音频文件url</li>
<li>outSystemSoundID:声音id（此函数会将音效文件加入到系统音频服务中并返回一个长整形ID）<br>*/<br></li></ul></span><span style="background: white; color: black">AudioServicesCreateSystemSoundID((__bridge CFURLRef)(fileUrl), &amp;soundID);<br></span><span style="background: white; color: green">//如果需要在播放完之后执行某些操作，可以调用如下方法注册一个播放完成回调函数<br></span><span style="background: white; color: black">AudioServicesAddSystemSoundCompletion(soundID, NULL, NULL, soundCompleteCallback, NULL);<br></span><span style="background: white; color: green">//2.播放音频<br></span><span style="background: white; color: black">AudioServicesPlaySystemSound(soundID);</span><span style="background: white; color: green">//播放音效<br>//    AudioServicesPlayAlertSound(soundID);//播放音效并震动<br></span><span style="background: white; color: black">}</span></li>
</ul>


<p>@end</p>
<p></p><h2 id="music">音乐</h2><p></p>
<p></p><p>如果播放较大的音频或者要对音频有精确的控制则System Sound Service可能就很难满足实际需求了，通常这种情况会选择使用AVFoundation.framework中的AVAudioPlayer来实现。AVAudioPlayer可以看成一个播放器，它支持多种<a href="https://developer.apple.com/library/ios/documentation/AVFoundation/Reference/AVFoundation_Constants/index.html#//apple_ref/doc/constant_group/File_Format_UTIs" target="_blank" rel="external">音频格式</a>，而且能够进行进度、音量、播放速度等控制。首先简单看一下AVAudioPlayer常用的属性和方法：</p><p></p>
<p><table class="kc-table" cellspacing="0" cellpadding="0" width="100%" border="0"></table></p>
<p><tbody></tbody></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="50%">属性</td></p>
<p><td valign="top" width="50%">说明</td></p>
<p><tr></tr></p>
<p><td valign="top">@property(readonly, getter=isPlaying) BOOL playing</td></p>
<p><td valign="top">是否正在播放，只读</td></p>
<p><tr></tr></p>
<p><td valign="top">@property(readonly) NSUInteger numberOfChannels</td></p>
<p><td valign="top">音频声道数，只读</td></p>
<p><tr></tr></p>
<p><td valign="top">@property(readonly) NSTimeInterval duration</td></p>
<p><td valign="top">音频时长</td></p>
<p><tr></tr></p>
<p><td valign="top">@property(readonly) NSURL *url</td></p>
<p><td valign="top">音频文件路径，只读</td></p>
<p><tr></tr></p>
<p><td valign="top">@property(readonly) NSData *data</td></p>
<p><td valign="top">音频数据，只读</td></p>
<p><tr></tr></p>
<p><td valign="top">@property float pan</td></p>
<p><td valign="top">立体声平衡，如果为-1.0则完全左声道，如果0.0则左右声道平衡，如果为1.0则完全为右声道</td></p>
<p><tr></tr></p>
<p><td valign="top">@property float volume</td></p>
<p><td valign="top">音量大小，范围0-1.0</td></p>
<p><tr></tr></p>
<p><td valign="top">@property BOOL enableRate</td></p>
<p><td valign="top">是否允许改变播放速率</td></p>
<p><tr></tr></p>
<p><td valign="top">@property float rate</td></p>
<p><td valign="top">播放速率，范围0.5-2.0，如果为1.0则正常播放，如果要修改播放速率则必须设置enableRate为YES</td></p>
<p><tr></tr></p>
<p><td valign="top">@property NSTimeInterval currentTime</td></p>
<p><td valign="top">当前播放时长</td></p>
<p><tr></tr></p>
<p><td valign="top">@property(readonly) NSTimeInterval deviceCurrentTime</td></p>
<p><td valign="top">输出设备播放音频的时间，注意如果播放中被暂停此时间也会继续累加</td></p>
<p><tr></tr></p>
<p><td valign="top">@property NSInteger numberOfLoops</td></p>
<p><td valign="top">循环播放次数，如果为0则不循环，如果小于0则无限循环，大于0则表示循环次数</td></p>
<p><tr></tr></p>
<p><td valign="top">@property(readonly) NSDictionary *settings</td></p>
<p><td valign="top">音频播放设置信息，只读</td></p>
<p><tr></tr></p>
<p><td valign="top">@property(getter=isMeteringEnabled) BOOL meteringEnabled</td></p>
<p><td valign="top">是否启用音频测量，默认为NO，一旦启用音频测量可以通过updateMeters方法更新测量值</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top">对象方法</td></p>
<p><td valign="top">说明</td></p>
<p><tr></tr></p>
<p><td valign="top">- (instancetype)initWithContentsOfURL:(NSURL <em>)url error:(NSError *</em>)outError</td></p>
<p><td valign="top">使用文件URL初始化播放器，注意这个URL不能是HTTP URL，AVAudioPlayer不支持加载网络媒体流，只能播放本地文件</td></p>
<p><tr></tr></p>
<p><td valign="top">- (instancetype)initWithData:(NSData <em>)data error:(NSError *</em>)outError</td></p>
<p><td valign="top">使用NSData初始化播放器，注意使用此方法时必须文件格式和文件后缀一致，否则出错，所以相比此方法更推荐使用上述方法或- (instancetype)initWithData:(NSData <em>)data fileTypeHint:(NSString </em>)utiString error:(NSError **)outError方法进行初始化</td></p>
<p><tr></tr></p>
<p><td valign="top">- (BOOL)prepareToPlay;</td></p>
<p><td valign="top">加载音频文件到缓冲区，注意即使在播放之前音频文件没有加载到缓冲区程序也会隐式调用此方法。</td></p>
<p><tr></tr></p>
<p><td valign="top">- (BOOL)play;</td></p>
<p><td valign="top">播放音频文件</td></p>
<p><tr></tr></p>
<p><td valign="top">- (BOOL)playAtTime:(NSTimeInterval)time</td></p>
<p><td valign="top">在指定的时间开始播放音频</td></p>
<p><tr></tr></p>
<p><td valign="top">- (void)pause;</td></p>
<p><td valign="top">暂停播放</td></p>
<p><tr></tr></p>
<p><td valign="top">- (void)stop;</td></p>
<p><td valign="top">停止播放</td></p>
<p><tr></tr></p>
<p><td valign="top">- (void)updateMeters</td></p>
<p><td valign="top">更新音频测量值，注意如果要更新音频测量值必须设置meteringEnabled为YES，通过音频测量值可以即时获得音频分贝等信息</td></p>
<p><tr></tr></p>
<p><td valign="top">- (float)peakPowerForChannel:(NSUInteger)channelNumber; </td></p>
<p><td valign="top">获得指定声道的分贝峰值，注意如果要获得分贝峰值必须在此之前调用updateMeters方法</td></p>
<p><tr></tr></p>
<p><td valign="top">- (float)averagePowerForChannel:(NSUInteger)channelNumber</td></p>
<p><td valign="top">获得指定声道的分贝平均值，注意如果要获得分贝平均值必须在此之前调用updateMeters方法</td></p>
<p><tr></tr></p>
<p><td valign="top">@property(nonatomic, copy) NSArray *channelAssignments</td></p>
<p><td valign="top">获得或设置播放声道</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top">代理方法</td></p>
<p><td valign="top">说明</td></p>
<p><tr></tr></p>
<p><td valign="top">- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag</td></p>
<p><td valign="top">音频播放完成</td></p>
<p><tr></tr></p>
<p><td valign="top">- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer <em>)player error:(NSError </em>)error</td></p>
<p><td valign="top">音频解码发生错误</td></p>
<p></p><p>AVAudioPlayer的使用比较简单：</p><p></p>
<p><ol></ol></p>
<p><li>初始化AVAudioPlayer对象，此时通常指定本地文件路径。 </li></p>
<p><li>设置播放器属性，例如重复次数、音量大小等。 </li></p>
<p><li>调用play方法播放。</li></p>
<p></p><p>下面就使用AVAudioPlayer实现一个简单播放器，在这个播放器中实现了播放、暂停、显示播放进度功能，当然例如调节音量、设置循环模式、甚至是声波图像（通过分析音频分贝值）等功能都可以实现，这里就不再一一演示。界面效果如下：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260912543436719.png" target="_blank" rel="external"><img title="AudioPlayerScreen" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="AudioPlayerScreen" src="http://images.cnitblog.com/blog/62046/201412/260912573583432.png" width="320" height="568"></a></p><p></p>
<p></p><p>当然由于AVAudioPlayer一次只能播放一个音频文件，所有上一曲、下一曲其实可以通过创建多个播放器对象来完成，这里暂不实现。播放进度的实现主要依靠一个定时器实时计算当前播放时长和音频总时长的比例，另外为了演示委托方法，下面的代码中也实现了播放完成委托方法，通常如果有下一曲功能的话播放完可以触发下一曲音乐播放。下面是主要代码：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  KCAVAudioPlayer<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AVFoundation/AVFoundation.h&gt;<br></span><span style="background: white; color: blue">#define </span><span style="background: white; color: black">kMusicFile @</span><span style="background: white; color: #a31515">“刘若英 - 原来你也在这里.mp3”<br></span><span style="background: white; color: blue">#define </span><span style="background: white; color: black">kMusicSinger @</span><span style="background: white; color: #a31515">“刘若英”<br></span><span style="background: white; color: blue">#define </span><span style="background: white; color: black">kMusicTitle @</span><span style="background: white; color: #a31515">“原来你也在这里”<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()&lt;AVAudioPlayerDelegate&gt;<p></p>
<p>@</p></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) AVAudioPlayer <em>audioPlayer;</em></span><span style="background: white; color: green">//播放器<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UILabel controlPanel; </span><span style="background: white; color: green">//控制面板<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIProgressView <em>playProgress;</em></span><span style="background: white; color: green">//播放进度<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UILabel musicSinger; </span><span style="background: white; color: green">//演唱者<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton *playOrPause; </span><span style="background: white; color: green">//播放/暂停按钮(如果tag为0认为是暂停状态，1是播放状态)<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak ,nonatomic) NSTimer *timer;</span><span style="background: white; color: green">//进度更新定时器<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<ul>
<li><p>(</p></li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<p></p>
<p>  [self setupUI];</p>


<p>}</p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>初始化UI<br>*/<br></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setupUI{<br>self.title=kMusicTitle;<br>self.musicSinger.text=kMusicSinger;<br>}

<p>-(NSTimer *)timer{<br>    </p></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_timer) {<br>        _timer=[NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(updateProgress) userInfo:nil repeats:</span><span style="background: white; color: blue">true</span><span style="background: white; color: black">];<br>    }<br>    </span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_timer;<br>}<p></p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>创建播放器<br>*</li>
<li>@return 音频播放器<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(AVAudioPlayer )audioPlayer{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_audioPlayer) {<pre><code>NSString *urlStr=[[NSBundle mainBundle]pathForResource:kMusicFile ofType:nil];
NSURL *url=[NSURL fileURLWithPath:urlStr];
NSError *error=nil;
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//初始化播放器，注意这里的Url参数只能时文件路径，不支持HTTP Url
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_audioPlayer=[[AVAudioPlayer alloc]initWithContentsOfURL:url error:&amp;amp;error];
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//设置播放器属性
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_audioPlayer.numberOfLoops=0;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//设置为0不循环
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_audioPlayer.&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;delegate&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;=self;
[_audioPlayer prepareToPlay];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//加载音频文件到缓存
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(error){
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;初始化播放器过程发生错误,错误信息:%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;nil;
}
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_audioPlayer;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放音频<br>*/<br></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)play{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(![self.audioPlayer isPlaying]) {<pre><code>[self.audioPlayer play];
self.timer.fireDate=[NSDate distantPast];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//恢复定时器
</code></pre></span><span style="background: white; color: black">}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li><p>暂停播放<br>*/<br></p></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)pause{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([self.audioPlayer isPlaying]) {<p></p>
<pre><code>[self.audioPlayer pause];
self.timer.fireDate=[NSDate distantFuture];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//暂停定时器，注意不能调用invalidate方法，此方法会取消，之后无法恢复
</code></pre><p></p></span><span style="background: white; color: black">}<br>}<p></p>


<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>点击播放/暂停按钮<br>*</li>
<li>@param sender 播放/暂停按钮<br><em>/<br></em></li></ul></span><span style="background: white; color: black">- (IBAction)playClick:(UIButton )sender {<br></span><span style="background: white; color: blue">if</span><span style="background: white; color: black">(sender.tag){<pre><code>sender.tag=0;
[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;playing_btn_play_n&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateNormal];
[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;playing_btn_play_h&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateHighlighted];
[self pause];
</code></pre>}</span><span style="background: white; color: blue">else</span><span style="background: white; color: black">{<pre><code>sender.tag=1;
[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;playing_btn_pause_n&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateNormal];
[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;playing_btn_pause_h&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateHighlighted];
[self play];
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>更新播放进度<br>*/<br></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)updateProgress{<br></span><span style="background: white; color: blue">float </span><span style="background: white; color: black">progress= self.audioPlayer.currentTime /self.audioPlayer.duration;<br>[self.playProgress setProgress:progress animated:</span><span style="background: white; color: blue">true</span><span style="background: white; color: black">];<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 播放器代理方法<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag{<br>    NSLog(@</span><span style="background: white; color: #a31515">“音乐播放完成…”</span><span style="background: white; color: black">);<br>}<p></p>
<p>@end</p></span></pre>运行效果： <p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260912583434030.gif" target="_blank" rel="external"><img title="AVAudioPlayer" style="display: inline" alt="AVAudioPlayer" src="http://images.cnitblog.com/blog/62046/201412/260912592026602.gif" width="320" height="594"></a></p><p></p>
<p></p><h2 id="audioSession">音频会话</h2><p></p>
<p></p><p>事实上上面的播放器还存在一些问题，例如通常我们看到的播放器即使退出到后台也是可以播放的，而这个播放器如果退出到后台它会自动暂停。如果要支持后台播放需要做下面几件事情：</p><p></p>
<p></p><p>1.设置后台运行模式：在plist文件中添加Required background modes，并且设置<strong>item 0=App plays audio or streams audio/video using AirPlay</strong>（其实可以直接通过Xcode在Project Targets-Capabilities-Background Modes中设置）</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260912599371744.png" target="_blank" rel="external"><img title="BackgroundModes" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="BackgroundModes" src="http://images.cnitblog.com/blog/62046/201412/260913004838643.png" width="736" height="41"></a></p><p></p>
<p></p><p>2.设置AVAudioSession的类型为AVAudioSessionCategoryPlayback并且调用setActive::方法启动会话。</p><pre class="code"><span style="background: white; color: black">    AVAudioSession *audioSession=[AVAudioSession sharedInstance];<br>    [audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];<br>    [audioSession setActive:YES error:nil];</span></pre><p></p>
<p></p><p>3.为了能够让应用退到后台之后支持耳机控制，建议添加<a href="http://www.cnblogs.com/kenshincui/p/3950646.html#remoteControl" target="_blank" rel="external">远程控制事件</a>（这一步不是后台播放必须的）</p><p></p>
<p></p><p>前两步是后台播放所必须设置的，第三步主要用于接收远程事件，这部分内容之前的文章中有详细介绍，如果这一步不设置虽让也能够在后台播放，但是无法获得音频控制权（如果在使用当前应用之前使用其他播放器播放音乐的话，此时如果按耳机播放键或者控制中心的播放按钮则会播放前一个应用的音频），并且不能使用耳机进行音频控制。第一步操作相信大家都很容易理解，如果应用程序要允许运行到后台必须设置，正常情况下应用如果进入后台会被挂起，通过该设置可以上应用程序继续在后台运行。但是第二步使用的AVAudioSession有必要进行一下详细的说明。</p><p></p>
<p></p><p>在iOS中每个应用都有一个音频会话，这个会话就通过AVAudioSession来表示。AVAudioSession同样存在于AVFoundation框架中，它是单例模式设计，通过sharedInstance进行访问。在使用Apple设备时大家会发现有些应用只要打开其他音频播放就会终止，而有些应用却可以和其他应用同时播放，在多种音频环境中如何去控制播放的方式就是通过音频会话来完成的。下面是音频会话的几种会话模式：</p><p></p>
<p><table class="kc-table" cellspacing="0" cellpadding="0" width="800" border="0"></table></p>
<p><tbody></tbody></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="291">会话类型</td></p>
<p><td valign="top" width="349">说明</td></p>
<p><td valign="top" width="48">是否要求输入</td></p>
<p><td valign="top" width="48">是否要求输出</td></p>
<p><td valign="top" width="64">是否遵从静音键</td></p>
<p><tr></tr></p>
<p><td valign="top" width="291">AVAudioSessionCategoryAmbient</td></p>
<p><td valign="top" width="349">混音播放，可以与其他音频应用同时播放</td></p>
<p><td valign="top" width="48">否</td></p>
<p><td valign="top" width="48">是</td></p>
<p><td valign="top" width="64">是</td></p>
<p><tr></tr></p>
<p><td valign="top" width="291">AVAudioSessionCategorySoloAmbient</td></p>
<p><td valign="top" width="349">独占播放</td></p>
<p><td valign="top" width="48">否</td></p>
<p><td valign="top" width="48">是</td></p>
<p><td valign="top" width="64">是</td></p>
<p><tr></tr></p>
<p><td valign="top" width="291">AVAudioSessionCategoryPlayback</td></p>
<p><td valign="top" width="349">后台播放，也是独占的</td></p>
<p><td valign="top" width="48">否</td></p>
<p><td valign="top" width="48">是</td></p>
<p><td valign="top" width="64">否</td></p>
<p><tr></tr></p>
<p><td valign="top" width="291">AVAudioSessionCategoryRecord</td></p>
<p><td valign="top" width="349">录音模式，用于录音时使用</td></p>
<p><td valign="top" width="48">是</td></p>
<p><td valign="top" width="48">否</td></p>
<p><td valign="top" width="64">否</td></p>
<p><tr></tr></p>
<p><td valign="top" width="291">AVAudioSessionCategoryPlayAndRecord</td></p>
<p><td valign="top" width="349">播放和录音，此时可以录音也可以播放</td></p>
<p><td valign="top" width="48">是</td></p>
<p><td valign="top" width="48">是</td></p>
<p><td valign="top" width="64">否</td></p>
<p><tr></tr></p>
<p><td valign="top" width="291">AVAudioSessionCategoryAudioProcessing</td></p>
<p><td valign="top" width="349">硬件解码音频，此时不能播放和录制 </td></p>
<p><td valign="top" width="48">否</td></p>
<p><td valign="top" width="48">否</td></p>
<p><td valign="top" width="64">否</td></p>
<p><tr></tr></p>
<p><td valign="top" width="291">AVAudioSessionCategoryMultiRoute</td></p>
<p><td valign="top" width="349">多种输入输出，例如可以耳机、USB设备同时播放</td></p>
<p><td valign="top" width="48">是</td></p>
<p><td valign="top" width="48">是</td></p>
<p><td valign="top" width="64">否</td></p>
<p></p><p><em>注意：是否遵循静音键表示在播放过程中如果用户通过硬件设置为静音是否能关闭声音。</em></p><p></p>
<p></p><p>根据前面对音频会话的理解，相信大家开发出能够在后台播放的音频播放器并不难，但是注意一下，在前面的代码中也提到设置完音频会话类型之后需要调用setActive::方法将会话激活才能起作用。类似的，如果一个应用已经在播放音频，打开我们的应用之后设置了在后台播放的会话类型，此时其他应用的音频会停止而播放我们的音频，如果希望我们的程序音频播放完之后（关闭或退出到后台之后）能够继续播放其他应用的音频的话则可以调用setActive::方法关闭会话。代码如下：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  KCAVAudioPlayer<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//  AVAudioSession 音频会话<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AVFoundation/AVFoundation.h&gt;<br></span><span style="background: white; color: blue">#define </span><span style="background: white; color: black">kMusicFile @</span><span style="background: white; color: #a31515">“刘若英 - 原来你也在这里.mp3”<br></span><span style="background: white; color: blue">#define </span><span style="background: white; color: black">kMusicSinger @</span><span style="background: white; color: #a31515">“刘若英”<br></span><span style="background: white; color: blue">#define </span><span style="background: white; color: black">kMusicTitle @</span><span style="background: white; color: #a31515">“原来你也在这里”<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()&lt;AVAudioPlayerDelegate&gt;<p></p>
<p>@</p></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) AVAudioPlayer <em>audioPlayer;</em></span><span style="background: white; color: green">//播放器<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UILabel controlPanel; </span><span style="background: white; color: green">//控制面板<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIProgressView <em>playProgress;</em></span><span style="background: white; color: green">//播放进度<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UILabel musicSinger; </span><span style="background: white; color: green">//演唱者<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton *playOrPause; </span><span style="background: white; color: green">//播放/暂停按钮(如果tag为0认为是暂停状态，1是播放状态)<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak ,nonatomic) NSTimer *timer;</span><span style="background: white; color: green">//进度更新定时器<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<ul>
<li><p>(</p></li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<p></p>
<p>  [self setupUI];</p>


<p>}</p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>显示当面视图控制器时注册远程事件<br>*</li>
<li>@param animated 是否以动画的形式显示<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewWillAppear:(BOOL)animated{<br>[super viewWillAppear:animated];<br></span><span style="background: white; color: green">//开启远程控制<br></span><span style="background: white; color: black">[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];<br></span><span style="background: white; color: green">//作为第一响应者<br>//[self becomeFirstResponder];<br></span><span style="background: white; color: black">}<br></span><span style="background: white; color: green">/*
<li>当前控制器视图不显示时取消远程控制<br>*</li>
<li>@param animated 是否以动画的形式消失<br>*/<br></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewWillDisappear:(BOOL)animated{<br>[super viewWillDisappear:animated];<br>[[UIApplication sharedApplication] endReceivingRemoteControlEvents];<br></span><span style="background: white; color: green">//[self resignFirstResponder];<br></span><span style="background: white; color: black">}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>初始化UI<br>*/<br></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setupUI{<br>self.title=kMusicTitle;<br>self.musicSinger.text=kMusicSinger;<br>}

<p>-(NSTimer *)timer{<br>    </p></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_timer) {<br>        _timer=[NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(updateProgress) userInfo:nil repeats:</span><span style="background: white; color: blue">true</span><span style="background: white; color: black">];<br>    }<br>    </span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_timer;<br>}<p></p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>创建播放器<br>*</li>
<li>@return 音频播放器<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(AVAudioPlayer )audioPlayer{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_audioPlayer) {<pre><code>NSString *urlStr=[[NSBundle mainBundle]pathForResource:kMusicFile ofType:nil];
NSURL *url=[NSURL fileURLWithPath:urlStr];
NSError *error=nil;
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//初始化播放器，注意这里的Url参数只能时文件路径，不支持HTTP Url
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_audioPlayer=[[AVAudioPlayer alloc]initWithContentsOfURL:url error:&amp;amp;error];
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//设置播放器属性
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_audioPlayer.numberOfLoops=0;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//设置为0不循环
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_audioPlayer.&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;delegate&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;=self;
[_audioPlayer prepareToPlay];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//加载音频文件到缓存
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(error){
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;初始化播放器过程发生错误,错误信息:%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;nil;
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//设置后台播放模式
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;AVAudioSession *audioSession=[AVAudioSession sharedInstance];
[audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];
</code></pre></span><span style="background: white; color: green">//        [audioSession setCategory:AVAudioSessionCategoryPlayback withOptions:AVAudioSessionCategoryOptionAllowBluetooth error:nil];<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;[audioSession setActive:YES error:nil];
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//添加通知，拔出耳机后暂停播放
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(routeChange:) name:AVAudioSessionRouteChangeNotification object:nil];
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_audioPlayer;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放音频<br>*/<br></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)play{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(![self.audioPlayer isPlaying]) {<pre><code>[self.audioPlayer play];
self.timer.fireDate=[NSDate distantPast];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//恢复定时器
</code></pre></span><span style="background: white; color: black">}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li><p>暂停播放<br>*/<br></p></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)pause{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([self.audioPlayer isPlaying]) {<p></p>
<pre><code>[self.audioPlayer pause];
self.timer.fireDate=[NSDate distantFuture];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//暂停定时器，注意不能调用invalidate方法，此方法会取消，之后无法恢复
</code></pre><p></p></span><span style="background: white; color: black">}<br>}<p></p>


<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>点击播放/暂停按钮<br>*</li>
<li>@param sender 播放/暂停按钮<br><em>/<br></em></li></ul></span><span style="background: white; color: black">- (IBAction)playClick:(UIButton )sender {<br></span><span style="background: white; color: blue">if</span><span style="background: white; color: black">(sender.tag){<pre><code>sender.tag=0;
[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;playing_btn_play_n&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateNormal];
[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;playing_btn_play_h&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateHighlighted];
[self pause];
</code></pre>}</span><span style="background: white; color: blue">else</span><span style="background: white; color: black">{<pre><code>sender.tag=1;
[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;playing_btn_pause_n&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateNormal];
[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;playing_btn_pause_h&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateHighlighted];
[self play];
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>更新播放进度<br>*/<br></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)updateProgress{<br></span><span style="background: white; color: blue">float </span><span style="background: white; color: black">progress= self.audioPlayer.currentTime /self.audioPlayer.duration;<br>[self.playProgress setProgress:progress animated:</span><span style="background: white; color: blue">true</span><span style="background: white; color: black">];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>一旦输出改变则执行此方法<br>*</li>
<li>@param notification 输出改变通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)routeChange:(NSNotification )notification{<br>NSDictionary *dic=notification.userInfo;<br></span><span style="background: white; color: blue">int </span><span style="background: white; color: black">changeReason= [dic[AVAudioSessionRouteChangeReasonKey] intValue];<br></span><span style="background: white; color: green">//等于AVAudioSessionRouteChangeReasonOldDeviceUnavailable表示旧输出不可用<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(changeReason==AVAudioSessionRouteChangeReasonOldDeviceUnavailable) {<pre><code>AVAudioSessionRouteDescription *routeDescription=dic[AVAudioSessionRouteChangePreviousRouteKey];
AVAudioSessionPortDescription *portDescription= [routeDescription.outputs firstObject];
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//原设备为耳机则暂停
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([portDescription.portType isEqualToString:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;Headphones&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;]) {
    [self pause];
}
</code></pre>}

<p></p></span><span style="background: white; color: green">//    [dic enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {<br>//        NSLog(@”%@:%@”,key,obj);<br>//    }];<br></span><span style="background: white; color: black">}<p></p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)dealloc{<br>    [[NSNotificationCenter defaultCenter] removeObserver:self name:AVAudioSessionRouteChangeNotification object:nil];<br>}<p></p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 播放器代理方法<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag{<br>    NSLog(@</span><span style="background: white; color: #a31515">“音乐播放完成…”</span><span style="background: white; color: black">);<br>    </span><span style="background: white; color: green">//根据实际情况播放完成可以将会话关闭，其他音频应用继续播放<br>    </span><span style="background: white; color: black">[[AVAudioSession sharedInstance]setActive:NO error:nil];<br>}<p></p>
<p>@end</p></span></pre><p></p>
<p></p><p>在上面的代码中还实现了拔出耳机暂停音乐播放的功能，这也是一个比较常见的功能。在iOS7及以后的版本中可以通过通知获得输出改变的通知，然后拿到通知对象后根据userInfo获得是何种改变类型，进而根据情况对音乐进行暂停操作。</p><p></p>
<p></p><h3>扩展–播放音乐库中的音乐</h3><p></p>
<p></p><p>众所周知音乐是iOS的重要组成播放，无论是iPod、iTouch、iPhone还是iPad都可以在iTunes购买音乐或添加本地音乐到音乐库中同步到你的iOS设备。在MediaPlayer.frameowork中有一个MPMusicPlayerController用于播放音乐库中的音乐。</p><p></p>
<p></p><p>下面先来看一下MPMusicPlayerController的常用属性和方法：</p><p></p>
<p><table class="kc-table" cellspacing="0" cellpadding="0" width="800" border="0"></table></p>
<p><tbody></tbody></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">属性</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) MPMusicPlaybackState playbackState</td></p>
<p><td valign="top" width="400">播放器状态，枚举类型：<br>MPMusicPlaybackStateStopped：停止播放 MPMusicPlaybackStatePlaying：正在播放<br>MPMusicPlaybackStatePaused：暂停播放<br>MPMusicPlaybackStateInterrupted：播放中断<br>MPMusicPlaybackStateSeekingForward：向前查找<br>MPMusicPlaybackStateSeekingBackward：向后查找</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) MPMusicRepeatMode repeatMode</td></p>
<p><td valign="top" width="400">重复模式，枚举类型：<br>MPMusicRepeatModeDefault：默认模式，使用用户的首选项（系统音乐程序设置）<br>MPMusicRepeatModeNone：不重复<br>MPMusicRepeatModeOne：单曲循环<br>MPMusicRepeatModeAll：在当前列表内循环</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) MPMusicShuffleMode shuffleMode</td></p>
<p><td valign="top" width="400">随机播放模式，枚举类型：<br>MPMusicShuffleModeDefault：默认模式，使用用户首选项（系统音乐程序设置）<br>MPMusicShuffleModeOff：不随机播放<br>MPMusicShuffleModeSongs：按歌曲随机播放<br>MPMusicShuffleModeAlbums：按专辑随机播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, copy) MPMediaItem *nowPlayingItem</td></p>
<p><td valign="top" width="400">正在播放的音乐项</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) NSUInteger indexOfNowPlayingItem </td></p>
<p><td valign="top" width="400">当前正在播放的音乐在播放队列中的索引</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic, readonly) BOOL isPreparedToPlay</td></p>
<p><td valign="top" width="400">是否准好播放准备</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic) NSTimeInterval currentPlaybackTime</td></p>
<p><td valign="top" width="400">当前已播放时间，单位：秒</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic) float currentPlaybackRate</td></p>
<p><td valign="top" width="400">当前播放速度，是一个播放速度倍率，0表示暂停播放，1代表正常速度</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">类方法</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">+ (MPMusicPlayerController *)applicationMusicPlayer;</td></p>
<p><td valign="top" width="400">获取应用播放器，注意此类播放器无法在后台播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">+ (MPMusicPlayerController *)systemMusicPlayer</td></p>
<p><td valign="top" width="400">获取系统播放器，支持后台播放</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">对象方法</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)setQueueWithQuery:(MPMediaQuery *)query</td></p>
<p><td valign="top" width="400">使用媒体队列设置播放源媒体队列</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)setQueueWithItemCollection:(MPMediaItemCollection *)itemCollection</td></p>
<p><td valign="top" width="400">使用媒体项集合设置播放源媒体队列</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)skipToNextItem</td></p>
<p><td valign="top" width="400">下一曲</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)skipToBeginning</td></p>
<p><td valign="top" width="400">从起始位置播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)skipToPreviousItem</td></p>
<p><td valign="top" width="400">上一曲</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)beginGeneratingPlaybackNotifications</td></p>
<p><td valign="top" width="400">开启播放通知，注意不同于其他播放器，MPMusicPlayerController要想获得通知必须首先开启，默认情况无法获得通知</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)endGeneratingPlaybackNotifications</td></p>
<p><td valign="top" width="400">关闭播放通知</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)prepareToPlay</td></p>
<p><td valign="top" width="400">做好播放准备（加载音频到缓冲区），在使用play方法播放时如果没有做好准备回自动调用该方法</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)play</td></p>
<p><td valign="top" width="400">开始播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)pause</td></p>
<p><td valign="top" width="400">暂停播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)stop</td></p>
<p><td valign="top" width="400">停止播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)beginSeekingForward</td></p>
<p><td valign="top" width="400">开始向前查找（快进）</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)beginSeekingBackward</td></p>
<p><td valign="top" width="400">开始向后查找（快退）</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)endSeeking</td></p>
<p><td valign="top" width="400">结束查找</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">通知</td></p>
<p><td valign="top" width="400">说明<br>（注意：要想获得MPMusicPlayerController通知必须首先调用beginGeneratingPlaybackNotifications开启通知）</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMusicPlayerControllerPlaybackStateDidChangeNotification</td></p>
<p><td valign="top" width="400">播放状态改变</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMusicPlayerControllerNowPlayingItemDidChangeNotification</td></p>
<p><td valign="top" width="400">当前播放音频改变</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMusicPlayerControllerVolumeDidChangeNotification</td></p>
<p><td valign="top" width="400">声音大小改变</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMediaPlaybackIsPreparedToPlayDidChangeNotification</td></p>
<p><td valign="top" width="400">准备好播放</td></p>
<p><ul></ul></p>
<p><li>MPMusicPlayerController有两种播放器：applicationMusicPlayer和systemMusicPlayer，前者在应用退出后音乐播放会自动停止，后者在应用停止后不会退出播放状态。 </li></p>
<p><li>MPMusicPlayerController加载音乐不同于前面的AVAudioPlayer是通过一个文件路径来加载，而是需要一个播放队列。在MPMusicPlayerController中提供了两个方法来加载播放队列<strong>：- (void)setQueueWithQuery:(MPMediaQuery <em>)query</em></strong>和<strong>- (void)setQueueWithItemCollection:(MPMediaItemCollection )itemCollection</strong>，正是由于它的播放音频来源是一个队列，因此MPMusicPlayerController支持上一曲、下一曲等操作。</li></p>
<p></p><p>那么接下来的问题就是如何获取MPMediaQueue或者MPMediaItemCollection？MPMediaQueue对象有一系列的类方法来获得媒体队列：</p><p></p>
<p></p><p><em>+ (MPMediaQuery <em>)albumsQuery;<br>+ (MPMediaQuery </em>)artistsQuery;<br>+ (MPMediaQuery <em>)songsQuery;<br>+ (MPMediaQuery </em>)playlistsQuery;<br>+ (MPMediaQuery <em>)podcastsQuery;<br>+ (MPMediaQuery </em>)audiobooksQuery;<br>+ (MPMediaQuery <em>)compilationsQuery;<br>+ (MPMediaQuery </em>)composersQuery;<br>+ (MPMediaQuery *)genresQuery;</em></p><p></p>
<p></p><p>有了这些方法，就可以很容易获到歌曲、播放列表、专辑媒体等媒体队列了，这样就可以通过<strong>：- (void)setQueueWithQuery:(MPMediaQuery <em>)query</em></strong>方法设置音乐来源了<strong>。</strong>又或者得到<strong>MPMediaQueue</strong>之后创建<strong>MPMediaItemCollection，</strong>使用<strong>- (void)setQueueWithItemCollection:(MPMediaItemCollection )itemCollection</strong>设置音乐来源。</p><p></p>
<p></p><p>有时候可能希望用户自己来选择要播放的音乐，这时可以使用MPMediaPickerController，它是一个视图控制器，类似于UIImagePickerController，选择完播放来源后可以在其代理方法中获得MPMediaItemCollection对象。</p><p></p>
<p></p><p>无论是通过哪种方式获得MPMusicPlayerController的媒体源，可能都希望将每个媒体的信息显示出来，这时候可以通过MPMediaItem对象获得。一个MPMediaItem代表一个媒体文件，通过它可以访问媒体标题、专辑名称、专辑封面、音乐时长等等。无论是MPMediaQueue还是MPMediaItemCollection都有一个items属性，它是MPMediaItem数组，通过这个属性可以获得MPMediaItem对象。</p><p></p>
<p></p><p>下面就简单看一下MPMusicPlayerController的使用，在下面的例子中简单演示了音乐的选择、播放、暂停、通知、下一曲、上一曲功能，相信有了上面的概念，代码读起来并不复杂（示例中是直接通过MPMeidaPicker进行音乐选择的，但是仍然提供了两个方法getLocalMediaQuery和getLocalMediaItemCollection来演示如何直接通过MPMediaQueue获得媒体队列或媒体集合）：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  MPMusicPlayerController<br>//<br>//  Created by Kenshin Cui 14/03/30<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;MediaPlayer/MediaPlayer.h&gt;<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()&lt;MPMediaPickerControllerDelegate&gt;<p></p>
<p>@</p></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) MPMediaPickerController <em>mediaPicker;</em></span><span style="background: white; color: green">//媒体选择控制器<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) MPMusicPlayerController musicPlayer; </span><span style="background: white; color: green">//音乐播放器<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<ul>
<li>(</li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<br>}

<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)dealloc{<br>    [self.musicPlayer endGeneratingPlaybackNotifications];<br>}<p></p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>获得音乐播放器<br>*</li>
<li>@return 音乐播放器<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(MPMusicPlayerController )musicPlayer{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_musicPlayer) {<pre><code>_musicPlayer=[MPMusicPlayerController systemMusicPlayer];
[_musicPlayer beginGeneratingPlaybackNotifications];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//开启通知，否则监控不到MPMusicPlayerController的通知
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;[self addNotification];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//添加通知
//如果不使用MPMediaPickerController可以使用如下方法获得音乐库媒体队列
//[_musicPlayer setQueueWithItemCollection:[self getLocalMediaItemCollection]];
</code></pre></span><span style="background: white; color: black">}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_musicPlayer;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>创建媒体选择器<br>*</li>
<li>@return 媒体选择器<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(MPMediaPickerController )mediaPicker{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_mediaPicker) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//初始化媒体选择器，这里设置媒体类型为音乐，其实这里也可以选择视频、广播等
</code></pre>//        _mediaPicker=[[MPMediaPickerController alloc]initWithMediaTypes:MPMediaTypeMusic];<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_mediaPicker=[[MPMediaPickerController alloc]initWithMediaTypes:MPMediaTypeAny];
_mediaPicker.allowsPickingMultipleItems=YES;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//允许多选
</code></pre>//        _mediaPicker.showsCloudItems=YES;//显示icloud选项<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_mediaPicker.prompt=@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;请选择要播放的音乐&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
_mediaPicker.&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;delegate&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;=self;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//设置选择器代理
</code></pre></span><span style="background: white; color: black">}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_mediaPicker;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得媒体队列<br>*</li>
<li>@return 媒体队列<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(MPMediaQuery )getLocalMediaQuery{<br>MPMediaQuery <em>mediaQueue=[MPMediaQuery songsQuery];<br></em></span><span style="background: white; color: blue">for </span><span style="background: white; color: black">(MPMediaItem item in mediaQueue.items) {<pre><code>NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;标题：%@,%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,item.title,item.albumTitle);
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">mediaQueue;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得媒体集合<br>*</li>
<li>@return 媒体集合<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(MPMediaItemCollection )getLocalMediaItemCollection{<br>MPMediaQuery <em>mediaQueue=[MPMediaQuery songsQuery];<br>NSMutableArray </em></span><span style="background: white; color: blue">array</span><span style="background: white; color: black">=[NSMutableArray </span><span style="background: white; color: blue">array</span><span style="background: white; color: black">];<br></span><span style="background: white; color: blue">for </span><span style="background: white; color: black">(MPMediaItem *item in mediaQueue.items) {<pre><code>[&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;array &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;addObject:item];
NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;标题：%@,%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,item.title,item.albumTitle);
</code></pre>}<br>MPMediaItemCollection *mediaItemCollection=[[MPMediaItemCollection alloc]initWithItems:[</span><span style="background: white; color: blue">array </span><span style="background: white; color: black">copy]];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">mediaItemCollection;<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - MPMediaPickerController代理方法<br></span><span style="background: white; color: green">//选择完成<br></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)mediaPicker:(MPMediaPickerController <em>)mediaPicker didPickMediaItems:(MPMediaItemCollection </em>)mediaItemCollection{<br>    MPMediaItem <em>mediaItem=[mediaItemCollection.items firstObject];</em></span><span style="background: white; color: green">//第一个播放音乐<br>    //注意很多音乐信息如标题、专辑、表演者、封面、时长等信息都可以通过MPMediaItem的valueForKey:方法得到,但是从iOS7开始都有对应的属性可以直接访问<br>//    NSString title= [mediaItem valueForKey:MPMediaItemPropertyAlbumTitle];<br>//    NSString <em>artist= [mediaItem valueForKey:MPMediaItemPropertyAlbumArtist];<br>//    MPMediaItemArtwork </em>artwork= [mediaItem valueForKey:MPMediaItemPropertyArtwork];<br>    //UIImage <em>image=[artwork imageWithSize:CGSizeMake(100, 100)];//专辑图片<br>    </em></span><span style="background: white; color: black">NSLog(@</span><span style="background: white; color: #a31515">“标题：%@,表演者：%@,专辑：%@”</span><span style="background: white; color: black">,mediaItem.title ,mediaItem.artist,mediaItem.albumTitle);<br>    [self.musicPlayer setQueueWithItemCollection:mediaItemCollection];<br>    [self dismissViewControllerAnimated:YES completion:nil];<br>}<br></span><span style="background: white; color: green">//取消选择<br></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)mediaPickerDidCancel:(MPMediaPickerController )mediaPicker{<br>    [self dismissViewControllerAnimated:YES completion:nil];<br>}<p></p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 通知<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>添加通知<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addNotification{<br>NSNotificationCenter notificationCenter=[NSNotificationCenter defaultCenter];<br>[notificationCenter addObserver:self selector:@selector(playbackStateChange:) name:MPMusicPlayerControllerPlaybackStateDidChangeNotification object:self.musicPlayer];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放状态改变通知<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)playbackStateChange:(NSNotification )notification{<br></span><span style="background: white; color: blue">switch </span><span style="background: white; color: black">(self.musicPlayer.playbackState) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMusicPlaybackStatePlaying:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;正在播放...&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMusicPlaybackStatePaused:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;播放暂停.&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMusicPlaybackStateStopped:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;播放停止.&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;default&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;:
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
</code></pre>}<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - UI事件<p></p>
<ul>
<li><p>(IBAction)selectClick:(UIButton *)sender {<br>  [self presentViewController:self.mediaPicker animated:YES completion:nil];<br>}</p>
</li>
<li><p>(IBAction)playClick:(UIButton *)sender {<br>  [self.musicPlayer play];<br>}</p>
</li>
<li><p>(IBAction)puaseClick:(UIButton *)sender {<br>  [self.musicPlayer pause];<br>}</p>
</li>
<li><p>(IBAction)stopClick:(UIButton *)sender {<br>  [self.musicPlayer stop];<br>}</p>
</li>
<li><p>(IBAction)nextClick:(UIButton *)sender {<br>  [self.musicPlayer skipToNextItem];<br>}</p>
</li>
<li><p>(IBAction)prevClick:(UIButton *)sender {<br>  [self.musicPlayer skipToPreviousItem];<br>}</p>
</li>
</ul>
<p>@end</p></span></pre><p></p>
<p></p><h2 id="audioRecord">录音</h2><p></p>
<p></p><p>除了上面说的，在AVFoundation框架中还要一个AVAudioRecorder类专门处理录音操作，它同样支持<a href="https://developer.apple.com/library/ios/documentation/MusicAudio/Reference/CoreAudioDataTypesRef/index.html#//apple_ref/doc/constant_group/Audio_Data_Format_Identifiers" target="_blank" rel="external">多种音频格式</a>。与AVAudioPlayer类似，你完全可以将它看成是一个录音机控制类，下面是常用的属性和方法：</p><p></p>
<p><table class="kc-table" cellspacing="0" cellpadding="0" width="800" border="0"></table></p>
<p><tbody></tbody></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">属性</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(readonly, getter=isRecording) BOOL recording;</td></p>
<p><td valign="top" width="400">是否正在录音，只读</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(readonly) NSURL *url</td></p>
<p><td valign="top" width="400">录音文件地址，只读</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(readonly) NSDictionary *settings</td></p>
<p><td valign="top" width="400">录音文件设置，只读</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(readonly) NSTimeInterval currentTime</td></p>
<p><td valign="top" width="400">录音时长，只读，注意仅仅在录音状态可用</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(readonly) NSTimeInterval deviceCurrentTime</td></p>
<p><td valign="top" width="400">输入设置的时间长度，只读，注意此属性一直可访问</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(getter=isMeteringEnabled) BOOL meteringEnabled;</td></p>
<p><td valign="top" width="400">是否启用录音测量，如果启用录音测量可以获得录音分贝等数据信息</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic, copy) NSArray *channelAssignments</td></p>
<p><td valign="top" width="400">当前录音的通道</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">对象方法</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (instancetype)initWithURL:(NSURL <em>)url settings:(NSDictionary </em>)settings error:(NSError **)outError</td></p>
<p><td valign="top" width="400">录音机对象初始化方法，注意其中的url必须是本地文件url，settings是录音格式、编码等设置</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (BOOL)prepareToRecord</td></p>
<p><td valign="top" width="400">准备录音，主要用于创建缓冲区，如果不手动调用，在调用record录音时也会自动调用</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (BOOL)record</td></p>
<p><td valign="top" width="400">开始录音</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (BOOL)recordAtTime:(NSTimeInterval)time</td></p>
<p><td valign="top" width="400">在指定的时间开始录音，一般用于录音暂停再恢复录音</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (BOOL)recordForDuration:(NSTimeInterval) duration</td></p>
<p><td valign="top" width="400">按指定的时长开始录音</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (BOOL)recordAtTime:(NSTimeInterval)time forDuration:(NSTimeInterval) duration</td></p>
<p><td valign="top" width="400">在指定的时间开始录音，并指定录音时长</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)pause;</td></p>
<p><td valign="top" width="400">暂停录音</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)stop;</td></p>
<p><td valign="top" width="400">停止录音</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (BOOL)deleteRecording;</td></p>
<p><td valign="top" width="400">删除录音，注意要删除录音此时录音机必须处于停止状态</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)updateMeters;</td></p>
<p><td valign="top" width="400">更新测量数据，注意只有meteringEnabled为YES此方法才可用</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (float)peakPowerForChannel:(NSUInteger)channelNumber;</td></p>
<p><td valign="top" width="400">指定通道的测量峰值，注意只有调用完updateMeters才有值</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (float)averagePowerForChannel:(NSUInteger)channelNumber</td></p>
<p><td valign="top" width="400">指定通道的测量平均值，注意只有调用完updateMeters才有值</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">代理方法</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)audioRecorderDidFinishRecording:(AVAudioRecorder *)recorder successfully:(BOOL)flag</td></p>
<p><td valign="top" width="400">完成录音</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)audioRecorderEncodeErrorDidOccur:(AVAudioRecorder <em>)recorder error:(NSError </em>)error</td></p>
<p><td valign="top" width="400">录音编码发生错误</td></p>
<p></p><p>AVAudioRecorder很多属性和方法跟AVAudioPlayer都是类似的,但是它的创建有所不同，在创建录音机时除了指定路径外还必须指定录音设置信息，因为录音机必须知道录音文件的格式、采样率、通道数、每个采样点的位数等信息，但是也并不是所有的信息都必须设置，通常只需要几个常用设置。关于录音设置详见帮助文档中的“<a href="https://developer.apple.com/library/ios/documentation/AVFoundation/Reference/AVFoundationAudioSettings_Constants/index.html" target="_blank" rel="external">AV Foundation Audio Settings Constants</a>”。</p><p></p>
<p></p><p>下面就使用AVAudioRecorder创建一个录音机，实现了录音、暂停、停止、播放等功能，实现效果大致如下：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913012025258.png" target="_blank" rel="external"><img title="AVAudioRecorderSnapshot" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="AVAudioRecorderSnapshot" src="http://images.cnitblog.com/blog/62046/201412/260913018904414.png" width="320" height="568"></a></p><p></p>
<p></p><p>在这个示例中将实行一个完整的录音控制，包括录音、暂停、恢复、停止，同时还会实时展示用户录音的声音波动，当用户点击完停止按钮还会自动播放录音文件。程序的构建主要分为以下几步：</p><p></p>
<p><ol></ol></p>
<p><li>设置音频会话类型为AVAudioSessionCategoryPlayAndRecord，因为程序中牵扯到录音和播放操作。 </li></p>
<p><li>创建录音机AVAudioRecorder，指定录音保存的路径并且设置录音属性，注意对于一般的录音文件要求的采样率、位数并不高，需要适当设置以保证录音文件的大小和效果。 </li></p>
<p><li>设置录音机代理以便在录音完成后播放录音，打开录音测量保证能够实时获得录音时的声音强度。（注意声音强度范围-160到0,0代表最大输入） </li></p>
<p><li>创建音频播放器AVAudioPlayer，用于在录音完成之后播放录音。 </li></p>
<p><li>创建一个定时器以便实时刷新录音测量值并更新录音强度到UIProgressView中显示。 </li></p>
<p><li>添加录音、暂停、恢复、停止操作，需要注意录音的恢复操作其实是有音频会话管理的，恢复时只要再次调用record方法即可，无需手动管理恢复时间等。</li></p>
<p></p><p>下面是主要代码：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  AVAudioRecorder<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AVFoundation/AVFoundation.h&gt;<br></span><span style="background: white; color: blue">#define </span><span style="background: white; color: black">kRecordAudioFile @</span><span style="background: white; color: #a31515">“myRecord.caf”<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()&lt;AVAudioRecorderDelegate&gt;<p></p>
<p>@</p></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) AVAudioRecorder <em>audioRecorder;</em></span><span style="background: white; color: green">//音频录音机<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) AVAudioPlayer audioPlayer;</span><span style="background: white; color: green">//音频播放器，用于播放录音文件<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) NSTimer *timer;</span><span style="background: white; color: green">//录音声波监控（注意这里暂时不对播放进行监控）<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton <em>record;</em></span><span style="background: white; color: green">//开始录音<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton pause;</span><span style="background: white; color: green">//暂停录音<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton <em>resume;</em></span><span style="background: white; color: green">//恢复录音<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton stop;</span><span style="background: white; color: green">//停止录音<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIProgressView *audioPower;</span><span style="background: white; color: green">//音频波动<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器视图方法<p></p>
<ul>
<li><p>(</p></li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<p></p>
<p>  [self setAudioSession];<br>}</p>


<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 私有方法<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>设置音频会话<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setAudioSession{<br>AVAudioSession audioSession=[AVAudioSession sharedInstance];<br></span><span style="background: white; color: green">//设置为播放和录音状态，以便可以在录制完之后播放录音<br></span><span style="background: white; color: black">[audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];<br>[audioSession setActive:YES error:nil];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得录音文件保存路径<br>*</li>
<li>@return 录音文件路径<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSURL )getSavePath{<br>NSString <em>urlStr=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];<br>urlStr=[urlStr stringByAppendingPathComponent:kRecordAudioFile];<br>NSLog(@</em></span><span style="background: white; color: #a31515">“file path:%@”</span><span style="background: white; color: black">,urlStr);<br>NSURL url=[NSURL fileURLWithPath:urlStr];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得录音文件设置<br>*</li>
<li>@return 录音设置<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSDictionary )getAudioSetting{<br>NSMutableDictionary *dicM=[NSMutableDictionary dictionary];<br></span><span style="background: white; color: green">//设置录音格式<br></span><span style="background: white; color: black">[dicM setObject:@(kAudioFormatLinearPCM) forKey:AVFormatIDKey];<br></span><span style="background: white; color: green">//设置录音采样率，8000是电话采样率，对于一般录音已经够了<br></span><span style="background: white; color: black">[dicM setObject:@(8000) forKey:AVSampleRateKey];<br></span><span style="background: white; color: green">//设置通道,这里采用单声道<br></span><span style="background: white; color: black">[dicM setObject:@(1) forKey:AVNumberOfChannelsKey];<br></span><span style="background: white; color: green">//每个采样点位数,分为8、16、24、32<br></span><span style="background: white; color: black">[dicM setObject:@(8) forKey:AVLinearPCMBitDepthKey];<br></span><span style="background: white; color: green">//是否使用浮点数采样<br></span><span style="background: white; color: black">[dicM setObject:@(YES) forKey:AVLinearPCMIsFloatKey];<br></span><span style="background: white; color: green">//….其他设置等<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">dicM;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>获得录音机对象<br>*</li>
<li>@return 录音机对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(AVAudioRecorder )audioRecorder{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_audioRecorder) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//创建录音文件保存路径
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;NSURL *url=[self getSavePath];
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//创建录音格式设置
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;NSDictionary *setting=[self getAudioSetting];
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//创建录音机
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;NSError *error=nil;
_audioRecorder=[[AVAudioRecorder alloc]initWithURL:url settings:setting error:&amp;amp;error];
_audioRecorder.&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;delegate&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;=self;
_audioRecorder.meteringEnabled=YES;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//如果要监控声波则必须设置为YES
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(error) {
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;创建录音机对象时发生错误，错误信息：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;nil;
}
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_audioRecorder;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>创建播放器<br>*</li>
<li>@return 播放器<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(AVAudioPlayer )audioPlayer{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_audioPlayer) {<pre><code>NSURL *url=[self getSavePath];
NSError *error=nil;
_audioPlayer=[[AVAudioPlayer alloc]initWithContentsOfURL:url error:&amp;amp;error];
_audioPlayer.numberOfLoops=0;
[_audioPlayer prepareToPlay];
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(error) {
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;创建播放器过程中发生错误，错误信息：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;nil;
}
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_audioPlayer;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>录音声波监控定制器<br>*</li>
<li>@return 定时器<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSTimer )timer{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_timer) {<pre><code>_timer=[NSTimer scheduledTimerWithTimeInterval:0.1f target:self selector:@selector(audioPowerChange) userInfo:nil repeats:YES];
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_timer;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>录音声波状态设置<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)audioPowerChange{<br>[self.audioRecorder updateMeters];</span><span style="background: white; color: green">//更新测量值<br></span><span style="background: white; color: blue">float </span><span style="background: white; color: black">power= [self.audioRecorder averagePowerForChannel:0];</span><span style="background: white; color: green">//取得第一个通道的音频，注意音频强度范围时-160到0<br></span><span style="background: white; color: black">CGFloat progress=(1.0/160.0)(power+160.0);<br>[self.audioPower setProgress:progress];<br>}<br></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - UI事件<br></span><span style="background: white; color: green">/**
<li>点击录音按钮<br>*</li>
<li>@param sender 录音按钮<br><em>/<br></em></li></span><span style="background: white; color: black">- (IBAction)recordClick:(UIButton )sender {<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(![self.audioRecorder isRecording]) {<pre><code>[self.audioRecorder record];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//首次使用应用时如果调用record方法会询问用户是否允许使用麦克风
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;self.timer.fireDate=[NSDate distantPast];
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>点击暂定按钮<br>*</li>
<li>@param sender 暂停按钮<br><em>/<br></em></li></ul></span><span style="background: white; color: black">- (IBAction)pauseClick:(UIButton )sender {<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([self.audioRecorder isRecording]) {<pre><code>[self.audioRecorder pause];
self.timer.fireDate=[NSDate distantFuture];
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>点击恢复按钮</li>
<li>恢复录音只需要再次调用record，AVAudioSession会帮助你记录上次录音位置并追加录音<br>*</li>
<li>@param sender 恢复按钮<br><em>/<br></em></li></ul></span><span style="background: white; color: black">- (IBAction)resumeClick:(UIButton )sender {<br>[self recordClick:sender];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>点击停止按钮<br>*</li>
<li>@param sender 停止按钮<br><em>/<br></em></li></ul></span><span style="background: white; color: black">- (IBAction)stopClick:(UIButton )sender {<br>[self.audioRecorder stop];<br>self.timer.fireDate=[NSDate distantFuture];<br>self.audioPower.progress=0.0;<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 录音机代理方法<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>录音完成，录音完成后播放录音<br>*</li>
<li>@param recorder 录音机对象</li>
<li>@param flag     是否成功<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)audioRecorderDidFinishRecording:(AVAudioRecorder )recorder successfully:(BOOL)flag{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(![self.audioPlayer isPlaying]) {<pre><code>[self.audioPlayer play];
</code></pre>}<br>NSLog(@</span><span style="background: white; color: #a31515">“录音完成!”</span><span style="background: white; color: black">);<br>}

<p>@end</p></span></pre><p></p>
<p></p><p>运行效果：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913026556014.gif" target="_blank" rel="external"><img title="AVAudioRecorder" style="display: inline" alt="AVAudioRecorder" src="http://images.cnitblog.com/blog/62046/201412/260913041086769.gif" width="320" height="594"></a></p><p></p>
<p></p><h2 id="audioQueueServices">音频队列服务</h2><p></p>
<p></p><p>大家应该已经注意到了，无论是前面的录音还是音频播放均不支持网络流媒体播放，当然对于录音来说这种需求可能不大，但是对于音频播放来说有时候就很有必要了。AVAudioPlayer只能播放本地文件，并且是一次性加载所以音频数据，初始化AVAudioPlayer时指定的URL也只能是File URL而不能是HTTP URL。当然，将音频文件下载到本地然后再调用AVAudioPlayer来播放也是一种播放网络音频的办法，但是这种方式最大的弊端就是必须等到整个音频播放完成才能播放，而不能使用流式播放，这往往在实际开发中是不切实际的。那么在iOS中如何播放网络流媒体呢？就是使用AudioToolbox框架中的音频队列服务Audio Queue Services。</p><p></p>
<p></p><p>使用音频队列服务完全可以做到音频播放和录制，首先看一下录音音频服务队列：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913047965925.png" target="_blank" rel="external"><img title="recording_architecture_2x" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="recording_architecture_2x" src="http://images.cnitblog.com/blog/62046/201412/260913054053041.png" width="800"></a></p><p></p>
<p></p><p>一个音频服务队列Audio Queue有三部分组成：</p><p></p>
<p></p><p>三个缓冲器Buffers:每个缓冲器都是一个存储音频数据的临时仓库。</p><p></p>
<p></p><p>一个缓冲队列Buffer Queue:一个包含音频缓冲器的有序队列。</p><p></p>
<p></p><p>一个回调Callback:一个自定义的队列回调函数。</p><p></p>
<p></p><p>声音通过输入设备进入缓冲队列中，首先填充第一个缓冲器；当第一个缓冲器填充满之后自动填充下一个缓冲器，同时会调用回调函数；在回调函数中需要将缓冲器中的音频数据写入磁盘，同时将缓冲器放回到缓冲队列中以便重用。下面是Apple官方关于音频队列服务的流程示意图：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913060773669.png" target="_blank" rel="external"><img title="recording_callback_function_2x" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="recording_callback_function_2x" src="http://images.cnitblog.com/blog/62046/201412/260913083277781.png" width="800"></a></p><p></p>
<p></p><p>类似的，看一下音频播放缓冲队列，其组成部分和录音缓冲队列类似。</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913092187408.png" target="_blank" rel="external"><img title="playback_architecture_2x" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="playback_architecture_2x" src="http://images.cnitblog.com/blog/62046/201412/260913098274523.png" width="800"></a></p><p></p>
<p></p><p>但是在音频播放缓冲队列中，回调函数调用的时机不同于音频录制缓冲队列，流程刚好相反。将音频读取到缓冲器中，一旦一个缓冲器填充满之后就放到缓冲队列中，然后继续填充其他缓冲器；当开始播放时，则从第一个缓冲器中读取音频进行播放；一旦播放完之后就会触发回调函数，开始播放下一个缓冲器中的音频，同时填充第一个缓冲器放；填充满之后再次放回到缓冲队列。下面是详细的流程：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913105306908.png" target="_blank" rel="external"><img title="playback_callback_function_2x" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="playback_callback_function_2x" src="http://images.cnitblog.com/blog/62046/201412/260913120303650.png" width="800"></a></p><p></p>
<p></p><p>当然，要明白音频队列服务的原理并不难，问题是如何实现这个自定义的回调函数，这其中我们有大量的工作要做，控制播放状态、处理异常中断、进行音频编码等等。由于牵扯内容过多，而且不是本文目的，如果以后有时间将另开一篇文章重点介绍，目前有很多第三方优秀框架可以直接使用，例如<a href="https://github.com/mattgallagher/AudioStreamer" target="_blank" rel="external">AudioStreamer</a>、<a href="https://github.com/muhku/FreeStreamer" target="_blank" rel="external">FreeStreamer</a>。由于前者当前只有非ARC版本，所以下面不妨使用FreeStreamer来简单演示在线音频播放的过程，当然在使用之前要做如下准备工作：</p><p></p>
<p></p><p>1.拷贝FreeStreamer中的Reachability.h、Reachability.m和Common、astreamer两个文件夹中的内容到项目中。</p><p></p>
<p></p><p>2.添加FreeStreamer使用的类库：CFNetwork.framework、AudioToolbox.framework、AVFoundation.framework<br>、libxml2.dylib、MediaPlayer.framework。</p><p></p>
<p></p><p>3.如果引用libxml2.dylib编译不通过，需要在Xcode的Targets-Build Settings-Header Build Path中添加<strong>$(SDKROOT)/usr/include/libxml2。</strong></p><p></p>
<p></p><p>4.将FreeStreamer中的FreeStreamerMobile-Prefix.pch文件添加到项目中并将<strong>Targets-Build Settings-Precompile Prefix Header</strong>设置为<strong>YES</strong>，在<strong>Targets-Build Settings-Prefix Header</strong>设置为<font color="#333333"><strong>$(SRCROOT)/项目名称/FreeStreamerMobile-Prefix.pch</strong></font>（因为Xcode6默认没有pch文件）</p><p></p>
<p></p><p>然后就可以编写代码播放网络音频了：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  AudioQueueServices<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//  使用FreeStreamer实现网络音频播放<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“FSAudioStream.h”<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()<p></p>
<p>@</p></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) FSAudioStream *audioStream;<p></p>
<p>@end</p>
<p>@implementation ViewController</p>
<ul>
<li><p>(</p></li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<p></p>
<p>  [self.audioStream play];<br>}</p>


<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得本地文件路径<br>*</li>
<li>@return 文件路径<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSURL )getFileUrl{<br>NSString <em>urlStr=[[NSBundle mainBundle]pathForResource:@</em></span><span style="background: white; color: #a31515">“刘若英 - 原来你也在这里.mp3” </span><span style="background: white; color: black">ofType:nil];<br>NSURL url=[NSURL fileURLWithPath:urlStr];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}<br>-(NSURL <em>)getNetworkUrl{<br>NSString </em>urlStr=@</span><span style="background: white; color: #a31515">“<a href="http://192.168.1.102/liu.mp3" target="_blank" rel="external">http://192.168.1.102/liu.mp3</a>“</span><span style="background: white; color: black">;<br>NSURL *url=[NSURL URLWithString:urlStr];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>创建FSAudioStream对象<br>*</li>
<li>@return FSAudioStream对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(FSAudioStream )audioStream{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_audioStream) {<pre><code>NSURL *url=[self getNetworkUrl];
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//创建FSAudioStream对象
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_audioStream=[[FSAudioStream alloc]initWithUrl:url];
_audioStream.onFailure=^(FSAudioStreamError error,NSString *description){
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;播放过程中发生错误，错误信息：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,description);
};
_audioStream.onCompletion=^(){
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;播放完成!&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
};
[_audioStream setVolume:0.5];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//设置声音
</code></pre></span><span style="background: white; color: black">}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_audioStream;<br>}

<p>@end</p></span></pre>其实FreeStreamer的功能很强大，不仅仅是播放本地、网络音频那么简单，它还支持播放列表、检查包内容、RSS订阅、播放中断等很多强大的功能，甚至还包含了一个音频分析器，有兴趣的朋友可以访问<a href="http://freestreamer.io/" target="_blank" rel="external">官网</a>查看详细用法 <p></p>
<p></p><h1 id="video">视频</h1><p></p>
<p></p><h2 id="mpMoviePlayerController">MPMoviePlayerController</h2><p></p>
<p></p><p>在iOS中播放视频可以使用MediaPlayer.framework种的MPMoviePlayerController类来完成，它支持本地视频和网络视频播放。这个类实现了MPMediaPlayback协议，因此具备一般的播放器控制功能，例如播放、暂停、停止等。但是MPMediaPlayerController自身并不是一个完整的视图控制器，如果要在UI中展示视频需要将view属性添加到界面中。下面列出了MPMoviePlayerController的常用属性和方法：</p><p></p>
<p><table class="kc-table" cellspacing="0" cellpadding="0" width="800" border="0"></table></p>
<p><tbody></tbody></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">属性</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, copy) NSURL *contentURL</td></p>
<p><td valign="top" width="400">播放媒体URL，这个URL可以是本地路径，也可以是网络路径</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) UIView *view</td></p>
<p><td valign="top" width="400">播放器视图，如果要显示视频必须将此视图添加到控制器视图中</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) UIView *backgroundView</td></p>
<p><td valign="top" width="400">播放器背景视图</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) MPMoviePlaybackState playbackState</td></p>
<p><td valign="top" width="400">媒体播放状态，枚举类型：<br>MPMoviePlaybackStateStopped：停止播放<br>MPMoviePlaybackStatePlaying：正在播放<br>MPMoviePlaybackStatePaused：暂停<br>MPMoviePlaybackStateInterrupted：中断<br>MPMoviePlaybackStateSeekingForward：向前定位<br>MPMoviePlaybackStateSeekingBackward：向后定位</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) MPMovieLoadState loadState</td></p>
<p><td valign="top" width="400">网络媒体加载状态，枚举类型：<br>MPMovieLoadStateUnknown：位置类型<br>MPMovieLoadStatePlayable：<br>MPMovieLoadStatePlaythroughOK：这种状态如果shouldAutoPlay为YES将自动播放<br>MPMovieLoadStateStalled：停滞状态</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) MPMovieControlStyle controlStyle</td></p>
<p><td valign="top" width="400">控制面板风格，枚举类型：<br>MPMovieControlStyleNone：无控制面板 <br>MPMovieControlStyleEmbedded：嵌入视频风格 <br>MPMovieControlStyleFullscreen：全屏 <br>MPMovieControlStyleDefault：默认风格</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) MPMovieRepeatMode repeatMode;</td></p>
<p><td valign="top" width="400">重复播放模式，枚举类型:<br>MPMovieRepeatModeNone:不重复，默认值<br>MPMovieRepeatModeOne:重复播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) BOOL shouldAutoplay</td></p>
<p><td valign="top" width="400">当网络媒体缓存到一定数据时是否自动播放，默认为YES</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, getter=isFullscreen) BOOL fullscreen</td></p>
<p><td valign="top" width="400">是否全屏展示，默认为NO，注意如果要通过此属性设置全屏必须在视图显示完成后设置，否则无效</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) MPMovieScalingMode scalingMode</td></p>
<p><td valign="top" width="400">视频缩放填充模式，枚举类型：<br>MPMovieScalingModeNone：不进行任何缩放<br>MPMovieScalingModeAspectFit：固定缩放比例并且尽量全部展示视频，不会裁切视频<br>MPMovieScalingModeAspectFill：固定缩放比例并填充满整个视图展示，可能会裁切视频<br>MPMovieScalingModeFill：不固定缩放比例压缩填充整个视图，视频不会被裁切但是比例失衡</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) BOOL readyForDisplay</td></p>
<p><td valign="top" width="400">是否有相关媒体被播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) MPMovieMediaTypeMask movieMediaTypes</td></p>
<p><td valign="top" width="400">媒体类别，枚举类型：<br>MPMovieMediaTypeMaskNone：未知类型<br>MPMovieMediaTypeMaskVideo：视频<br>MPMovieMediaTypeMaskAudio：音频</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) MPMovieSourceType movieSourceType</td></p>
<p><td valign="top" width="400">媒体源，枚举类型：<br>MPMovieSourceTypeUnknown：未知来源<br>MPMovieSourceTypeFile：本地文件<br>MPMovieSourceTypeStreaming：流媒体（直播或点播）</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) NSTimeInterval duration</td></p>
<p><td valign="top" width="400">媒体时长，如果未知则返回0</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) NSTimeInterval playableDuration</td></p>
<p><td valign="top" width="400">媒体可播放时长，主要用于表示网络媒体已下载视频时长</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly) CGSize naturalSize</td></p>
<p><td valign="top" width="400">视频实际尺寸，如果未知则返回CGSizeZero</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) NSTimeInterval initialPlaybackTime</td></p>
<p><td valign="top" width="400">起始播放时间</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) NSTimeInterval endPlaybackTime</td></p>
<p><td valign="top" width="400">终止播放时间</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic) BOOL allowsAirPlay</td></p>
<p><td valign="top" width="400">是否允许无线播放，默认为YES</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property (nonatomic, readonly, getter=isAirPlayVideoActive) BOOL airPlayVideoActive</td></p>
<p><td valign="top" width="400">当前媒体是否正在通过AirPlay播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic, readonly) BOOL isPreparedToPlay</td></p>
<p><td valign="top" width="400">是否准备好播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic) NSTimeInterval currentPlaybackTime</td></p>
<p><td valign="top" width="400">当前播放时间，单位：秒</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic) float currentPlaybackRate</td></p>
<p><td valign="top" width="400">当前播放速度，如果暂停则为0，正常速度为1.0，非0数据表示倍率</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">对象方法</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (instancetype)initWithContentURL:(NSURL *)url</td></p>
<p><td valign="top" width="400">使用指定的URL初始化媒体播放控制器对象</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)setFullscreen:(BOOL)fullscreen animated:(BOOL)animated</td></p>
<p><td valign="top" width="400">设置视频全屏，注意如果要通过此方法设置全屏则必须在其视图显示之后设置，否则无效</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)requestThumbnailImagesAtTimes:(NSArray *)playbackTimes timeOption:(MPMovieTimeOption)option</td></p>
<p><td valign="top" width="400">获取在指定播放时间的视频缩略图，第一个参数是获取缩略图的时间点数组；第二个参数代表时间点精度，枚举类型：<br>MPMovieTimeOptionNearestKeyFrame：时间点附近<br>MPMovieTimeOptionExact：准确时间</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)cancelAllThumbnailImageRequests</td></p>
<p><td valign="top" width="400">取消所有缩略图获取请求</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)prepareToPlay</td></p>
<p><td valign="top" width="400">准备播放，加载视频数据到缓存，当调用play方法时如果没有准备好会自动调用此方法</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)play</td></p>
<p><td valign="top" width="400">开始播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)pause</td></p>
<p><td valign="top" width="400">暂停播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)stop</td></p>
<p><td valign="top" width="400">停止播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)beginSeekingForward</td></p>
<p><td valign="top" width="400">向前定位</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)beginSeekingBackward</td></p>
<p><td valign="top" width="400">向后定位</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)endSeeking</td></p>
<p><td valign="top" width="400">停止快进/快退</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">通知</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerScalingModeDidChangeNotification</td></p>
<p><td valign="top" width="400">视频缩放填充模式发生改变</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerPlaybackDidFinishNotification</td></p>
<p><td valign="top" width="400">媒体播放完成或用户手动退出，具体完成原因可以通过通知userInfo中的key为MPMoviePlayerPlaybackDidFinishReasonUserInfoKey的对象获取</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerPlaybackStateDidChangeNotification</td></p>
<p><td valign="top" width="400">播放状态改变，可配合playbakcState属性获取具体状态</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerLoadStateDidChangeNotification</td></p>
<p><td valign="top" width="400">媒体网络加载状态改变</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerNowPlayingMovieDidChangeNotification</td></p>
<p><td valign="top" width="400">当前播放的媒体内容发生改变</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerWillEnterFullscreenNotification</td></p>
<p><td valign="top" width="400">将要进入全屏</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerDidEnterFullscreenNotification</td></p>
<p><td valign="top" width="400">进入全屏后</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerWillExitFullscreenNotification</td></p>
<p><td valign="top" width="400">将要退出全屏</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerDidExitFullscreenNotification</td></p>
<p><td valign="top" width="400">退出全屏后</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerIsAirPlayVideoActiveDidChangeNotification</td></p>
<p><td valign="top" width="400">当媒体开始通过AirPlay播放或者结束AirPlay播放</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerReadyForDisplayDidChangeNotification</td></p>
<p><td valign="top" width="400">视频显示状态改变</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMovieMediaTypesAvailableNotification</td></p>
<p><td valign="top" width="400">确定了媒体可用类型后</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMovieSourceTypeAvailableNotification</td></p>
<p><td valign="top" width="400">确定了媒体来源后</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMovieDurationAvailableNotification</td></p>
<p><td valign="top" width="400">确定了媒体播放时长后</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMovieNaturalSizeAvailableNotification</td></p>
<p><td valign="top" width="400">确定了媒体的实际尺寸后</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMoviePlayerThumbnailImageRequestDidFinishNotification</td></p>
<p><td valign="top" width="400">缩略图请求完成之后</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">MPMediaPlaybackIsPreparedToPlayDidChangeNotification</td></p>
<p><td valign="top" width="400">做好播放准备后</td></p>
<p></p><p>注意MPMediaPlayerController的状态等信息并不是通过代理来和外界交互的，而是通过通知中心，因此从上面的列表中可以看到常用的一些通知。由于MPMoviePlayerController本身对于媒体播放做了深度的封装，使用起来就相当简单：创建MPMoviePlayerController对象，设置frame属性，将MPMoviePlayerController的view添加到控制器视图中。下面的示例中将创建一个播放控制器并添加播放状态改变及播放完成的通知：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  MPMoviePlayerController<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;MediaPlayer/MediaPlayer.h&gt;<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()<p></p>
<p>@</p></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) MPMoviePlayerController *moviePlayer;</span><span style="background: white; color: green">//视频播放控制器<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器视图方法<p></p>
<ul>
<li><p>(</p></li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<p></p>
<p>  </p></span><span style="background: white; color: green">//播放<br>  </span><span style="background: white; color: black">[self.moviePlayer play];<p></p>
<p>  </p></span><span style="background: white; color: green">//添加通知<br>  </span><span style="background: white; color: black">[self addNotification];<p></p>


<p>}</p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)dealloc{<br>    </span><span style="background: white; color: green">//移除所有通知监控<br>    </span><span style="background: white; color: black">[[NSNotificationCenter defaultCenter] removeObserver:self];<br>}<p></p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 私有方法<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得本地文件路径<br>*</li>
<li>@return 文件路径<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSURL )getFileUrl{<br>NSString <em>urlStr=[[NSBundle mainBundle] pathForResource:@</em></span><span style="background: white; color: #a31515">“The New Look of OS X Yosemite.mp4” </span><span style="background: white; color: black">ofType:nil];<br>NSURL url=[NSURL fileURLWithPath:urlStr];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得网络文件路径<br>*</li>
<li>@return 文件路径<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSURL )getNetworkUrl{<br>NSString <em>urlStr=@</em></span><span style="background: white; color: #a31515">“<a href="http://192.168.1.161/The" target="_blank" rel="external">http://192.168.1.161/The</a> New Look of OS X Yosemite.mp4”</span><span style="background: white; color: black">;<br>urlStr=[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];<br>NSURL url=[NSURL URLWithString:urlStr];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>创建媒体播放控制器<br>*</li>
<li>@return 媒体播放控制器<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(MPMoviePlayerController )moviePlayer{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_moviePlayer) {<pre><code>NSURL *url=[self getNetworkUrl];
_moviePlayer=[[MPMoviePlayerController alloc]initWithContentURL:url];
_moviePlayer.view.frame=self.view.bounds;
_moviePlayer.view.autoresizingMask=UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight;
[self.view addSubview:_moviePlayer.view];
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_moviePlayer;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>添加通知监控媒体播放控制器状态<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addNotification{<br>NSNotificationCenter notificationCenter=[NSNotificationCenter defaultCenter];<br>[notificationCenter addObserver:self selector:@selector(mediaPlayerPlaybackStateChange:) name:MPMoviePlayerPlaybackStateDidChangeNotification object:self.moviePlayer];<br>[notificationCenter addObserver:self selector:@selector(mediaPlayerPlaybackFinished:) name:MPMoviePlayerPlaybackDidFinishNotification object:self.moviePlayer];

<p>}</p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放状态改变，注意播放完成时的状态是暂停<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)mediaPlayerPlaybackStateChange:(NSNotification )notification{<br></span><span style="background: white; color: blue">switch </span><span style="background: white; color: black">(self.moviePlayer.playbackState) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMoviePlaybackStatePlaying:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;正在播放...&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMoviePlaybackStatePaused:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;暂停播放.&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMoviePlaybackStateStopped:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;停止播放.&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;default&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;播放状态:%li&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,self.moviePlayer.playbackState);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放完成<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)mediaPlayerPlaybackFinished:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“播放完成.%li”</span><span style="background: white; color: black">,self.moviePlayer.playbackState);<br>}

<p>@end</p></span></pre><p></p>
<p></p><p>运行效果：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913230775742.gif" target="_blank" rel="external"><img title="MPMoviePlayerController" style="display: inline" alt="MPMoviePlayerController" src="http://images.cnitblog.com/blog/62046/201412/260913366718687.gif" width="320" height="594"></a><br>从上面的API大家也不难看出其实MPMoviePlayerController功能相当强大，日常开发中作为一般的媒体播放器也完全没有问题。MPMoviePlayerController除了一般的视频播放和控制外还有一些强大的功能，例如截取视频缩略图。请求视频缩略图时只要调用<strong>- (void)requestThumbnailImagesAtTimes:(NSArray *)playbackTimes timeOption:(MPMovieTimeOption)option</strong>方法指定获得缩略图的时间点，然后监控<strong>MPMoviePlayerThumbnailImageRequestDidFinishNotification</strong>通知，每个时间点的缩略图请求完成就会调用通知，在通知调用方法中可以通过<strong>MPMoviePlayerThumbnailImageKey</strong>获得UIImage对象处理即可。例如下面的程序演示了在程序启动后获得两个时间点的缩略图的过程，截图成功后保存到相册：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  MPMoviePlayerController<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//  视频截图<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;MediaPlayer/MediaPlayer.h&gt;<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()<p></p>
<p>@</p></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) MPMoviePlayerController *moviePlayer;</span><span style="background: white; color: green">//视频播放控制器<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器视图方法<p></p>
<ul>
<li><p>(</p></li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<p></p>
<p>  </p></span><span style="background: white; color: green">//播放<br>  </span><span style="background: white; color: black">[self.moviePlayer play];<p></p>
<p>  </p></span><span style="background: white; color: green">//添加通知<br>  </span><span style="background: white; color: black">[self addNotification];<p></p>
<p>  </p></span><span style="background: white; color: green">//获取缩略图<br>  </span><span style="background: white; color: black">[self thumbnailImageRequest];<br>}<p></p>


<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)dealloc{<br>    </span><span style="background: white; color: green">//移除所有通知监控<br>    </span><span style="background: white; color: black">[[NSNotificationCenter defaultCenter] removeObserver:self];<br>}<p></p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 私有方法<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得本地文件路径<br>*</li>
<li>@return 文件路径<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSURL )getFileUrl{<br>NSString <em>urlStr=[[NSBundle mainBundle] pathForResource:@</em></span><span style="background: white; color: #a31515">“The New Look of OS X Yosemite.mp4” </span><span style="background: white; color: black">ofType:nil];<br>NSURL url=[NSURL fileURLWithPath:urlStr];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得网络文件路径<br>*</li>
<li>@return 文件路径<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSURL )getNetworkUrl{<br>NSString <em>urlStr=@</em></span><span style="background: white; color: #a31515">“<a href="http://192.168.1.161/The" target="_blank" rel="external">http://192.168.1.161/The</a> New Look of OS X Yosemite.mp4”</span><span style="background: white; color: black">;<br>urlStr=[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];<br>NSURL url=[NSURL URLWithString:urlStr];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>创建媒体播放控制器<br>*</li>
<li>@return 媒体播放控制器<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(MPMoviePlayerController )moviePlayer{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_moviePlayer) {<pre><code>NSURL *url=[self getNetworkUrl];
_moviePlayer=[[MPMoviePlayerController alloc]initWithContentURL:url];
_moviePlayer.view.frame=self.view.bounds;
_moviePlayer.view.autoresizingMask=UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight;
[self.view addSubview:_moviePlayer.view];
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_moviePlayer;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>获取视频缩略图<br>*/<br></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)thumbnailImageRequest{<br></span><span style="background: white; color: green">//获取13.0s、21.5s的缩略图<br></span><span style="background: white; color: black">[self.moviePlayer requestThumbnailImagesAtTimes:@[@13.0,@21.5] timeOption:MPMovieTimeOptionNearestKeyFrame];<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器通知<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>添加通知监控媒体播放控制器状态<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addNotification{<br>NSNotificationCenter notificationCenter=[NSNotificationCenter defaultCenter];<br>[notificationCenter addObserver:self selector:@selector(mediaPlayerPlaybackStateChange:) name:MPMoviePlayerPlaybackStateDidChangeNotification object:self.moviePlayer];<br>[notificationCenter addObserver:self selector:@selector(mediaPlayerPlaybackFinished:) name:MPMoviePlayerPlaybackDidFinishNotification object:self.moviePlayer];<br>[notificationCenter addObserver:self selector:@selector(mediaPlayerThumbnailRequestFinished:) name:MPMoviePlayerThumbnailImageRequestDidFinishNotification object:self.moviePlayer];

<p>}</p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放状态改变，注意播放完成时的状态是暂停<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)mediaPlayerPlaybackStateChange:(NSNotification )notification{<br></span><span style="background: white; color: blue">switch </span><span style="background: white; color: black">(self.moviePlayer.playbackState) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMoviePlaybackStatePlaying:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;正在播放...&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMoviePlaybackStatePaused:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;暂停播放.&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMoviePlaybackStateStopped:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;停止播放.&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;default&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;播放状态:%li&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,self.moviePlayer.playbackState);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放完成<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)mediaPlayerPlaybackFinished:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“播放完成.%li”</span><span style="background: white; color: black">,self.moviePlayer.playbackState);<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>缩略图请求完成,此方法每次截图成功都会调用一次<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)mediaPlayerThumbnailRequestFinished:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“视频截图完成.”</span><span style="background: white; color: black">);<br>UIImage *image=notification.userInfo[MPMoviePlayerThumbnailImageKey];<br></span><span style="background: white; color: green">//保存图片到相册(首次调用会请求用户获得访问相册权限)<br></span><span style="background: white; color: black">UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);<br>}

<p>@end</p></span></pre><p></p>
<p></p><p>截图效果：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913389055272.png" target="_blank" rel="external"><img title="MPMoviePlayerController_Thumbnail1" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="MPMoviePlayerController_Thumbnail1" src="http://images.cnitblog.com/blog/62046/201412/260913394998158.png" width="320" height="590"></a>&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://images.cnitblog.com/blog/62046/201412/260913403749257.png" target="_blank" rel="external"><img title="MPMoviePlayerController_Thumbnail2" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="MPMoviePlayerController_Thumbnail2" src="http://images.cnitblog.com/blog/62046/201412/260913408122957.png" width="320" height="590"></a></p><p></p>
<p></p><h3>扩展–使用AVFoundation生成缩略图</h3><p></p>
<p></p><p>通过前面的方法大家应该已经看到，使用MPMoviePlayerController来生成缩略图足够简单，但是如果仅仅是是为了生成缩略图而不进行视频播放的话，此刻使用MPMoviePlayerController就有点大材小用了。其实使用AVFundation框架中的AVAssetImageGenerator就可以获取视频缩略图。使用AVAssetImageGenerator获取缩略图大致分为三个步骤：</p><p></p>
<p><ol></ol></p>
<p><li>创建AVURLAsset对象（此类主要用于获取媒体信息，包括视频、声音等）。 </li></p>
<p><li>根据AVURLAsset创建AVAssetImageGenerator对象。 </li></p>
<p><li>使用AVAssetImageGenerator的copyCGImageAtTime::方法获得指定时间点的截图。</li><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  AVAssetImageGenerator<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//</span></pre></p>
<p><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AVFoundation/AVFoundation.h&gt;</span></p>
<p><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()</span></p>
<p>@end</p>
<p>@implementation ViewController</p>
<ul>
<li><p>(<span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];</span></p>
<p>  <span style="background: white; color: green">//获取第13.0s的缩略图<br>  </span><span style="background: white; color: black">[self thumbnailImageRequest:13.0];<br>}</span></p>
</li>
</ul>
<p><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 私有方法<br></span><span style="background: white; color: green">/**</span></p>
<ul>
<li>取得本地文件路径<br>*</li>
<li>@return 文件路径<br><em>/<br><span style="background: white; color: black">-(NSURL </span></em>)getFileUrl{<br>NSString <em>urlStr=[[NSBundle mainBundle] pathForResource:@<span style="background: white; color: #a31515">“The New Look of OS X Yosemite.mp4” </span><span style="background: white; color: black">ofType:nil];<br>NSURL </span></em>url=[NSURL fileURLWithPath:urlStr];<br><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}</span></li>
</ul>
<p><span style="background: white; color: green">/**</span></p>
<ul>
<li>取得网络文件路径<br>*</li>
<li>@return 文件路径<br><em>/<br><span style="background: white; color: black">-(NSURL </span></em>)getNetworkUrl{<br>NSString <em>urlStr=@<span style="background: white; color: #a31515">“<a href="http://192.168.1.161/The" target="_blank" rel="external">http://192.168.1.161/The</a> New Look of OS X Yosemite.mp4”</span><span style="background: white; color: black">;<br>urlStr=[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];<br>NSURL </span></em>url=[NSURL URLWithString:urlStr];<br><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}</span></li>
</ul>
<p><span style="background: white; color: green">/**</span></p>
<ul>
<li>截取指定时间的视频缩略图<br>*</li>
<li>@param timeBySecond 时间点<br><em>/<br><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)thumbnailImageRequest:(CGFloat )timeBySecond{<br></span><span style="background: white; color: green">//创建URL<br></span><span style="background: white; color: black">NSURL </span></em>url=[self getNetworkUrl];<br><span style="background: white; color: green">//根据url创建AVURLAsset<br></span><span style="background: white; color: black">AVURLAsset <em>urlAsset=[AVURLAsset assetWithURL:url];<br></em></span><span style="background: white; color: green">//根据AVURLAsset创建AVAssetImageGenerator<br></span><span style="background: white; color: black">AVAssetImageGenerator imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];<br></span><span style="background: white; color: green">/*截图<ul>
<li>requestTime:缩略图创建时间</li>
<li>actualTime:缩略图实际生成的时间<br><em>/<br></em></li></ul></span><span style="background: white; color: black">NSError error=nil;<br>CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);</span><span style="background: white; color: green">//CMTime是表示电影时间信息的结构体，第一个参数表示是视频第几秒，第二个参数表示每秒帧数.(如果要活的某一秒的第几帧可以使用CMTimeMake方法)<br></span><span style="background: white; color: black">CMTime actualTime;<br>CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];<br></span><span style="background: white; color: blue">if</span><span style="background: white; color: black">(error){<br> NSLog(@</span><span style="background: white; color: #a31515">“截取视频缩略图时发生错误，错误信息：%@”</span><span style="background: white; color: black">,error.localizedDescription);<br> </span><span style="background: white; color: blue">return</span><span style="background: white; color: black">;<br>}<br>CMTimeShow(actualTime);<br>UIImage *image=[UIImage imageWithCGImage:cgImage];</span><span style="background: white; color: green">//转化为UIImage<br>//保存到相册<br></span><span style="background: white; color: black">UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);<br>CGImageRelease(cgImage);<br>}</span></li>
</ul>


<p>@end</p>
<p></p><p>生成的缩略图效果：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913413436627.png" target="_blank" rel="external"><img title="AVAssetImageGenerator_Thumbnail" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="AVAssetImageGenerator_Thumbnail" src="http://images.cnitblog.com/blog/62046/201412/260913418904527.png" width="320" height="590"></a></p><p></p>
<p></p><h2 id="mpMoviePlayerViewController">MPMoviePlayerViewController</h2><p></p>
<p></p><p>其实MPMoviePlayerController如果不作为嵌入视频来播放（例如在新闻中嵌入一个视频），通常在播放时都是占满一个屏幕的，特别是在iPhone、iTouch上。因此从iOS3.2以后苹果也在思考既然MPMoviePlayerController在使用时通常都是将其视图view添加到另外一个视图控制器中作为子视图，那么何不直接创建一个控制器视图内部创建一个MPMoviePlayerController属性并且默认全屏播放，开发者在开发的时候直接使用这个视图控制器。这个内部有一个MPMoviePlayerController的视图控制器就是MPMoviePlayerViewController，它继承于UIViewController。MPMoviePlayerViewController内部多了一个moviePlayer属性和一个带有url的初始化方法，同时它内部实现了一些作为模态视图展示所特有的功能，例如默认是全屏模式展示、弹出后自动播放、作为模态窗口展示时如果点击“Done”按钮会自动退出模态窗口等。在下面的示例中就不直接将播放器放到主视图控制器，而是放到一个模态视图控制器中，简单演示MPMoviePlayerViewController的使用。</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  MPMoviePlayerViewController<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//  MPMoviePlayerViewController使用<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;MediaPlayer/MediaPlayer.h&gt;<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()<p></p>
<p></p></span><span style="background: white; color: green">//播放器视图控制器<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) MPMoviePlayerViewController *moviePlayerViewController;<p></p>
<p>@end</p>
<p>@implementation ViewController</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器视图方法<p></p>
<ul>
<li>(</li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];

<p>}</p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)dealloc{<br>    </span><span style="background: white; color: green">//移除所有通知监控<br>    </span><span style="background: white; color: black">[[NSNotificationCenter defaultCenter] removeObserver:self];<br>}<p></p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 私有方法<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得本地文件路径<br>*</li>
<li>@return 文件路径<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSURL )getFileUrl{<br>NSString <em>urlStr=[[NSBundle mainBundle] pathForResource:@</em></span><span style="background: white; color: #a31515">“The New Look of OS X Yosemite.mp4” </span><span style="background: white; color: black">ofType:nil];<br>NSURL url=[NSURL fileURLWithPath:urlStr];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得网络文件路径<br>*</li>
<li>@return 文件路径<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(NSURL )getNetworkUrl{<br>NSString <em>urlStr=@</em></span><span style="background: white; color: #a31515">“<a href="http://192.168.1.161/The" target="_blank" rel="external">http://192.168.1.161/The</a> New Look of OS X Yosemite.mp4”</span><span style="background: white; color: black">;<br>urlStr=[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];<br>NSURL url=[NSURL URLWithString:urlStr];<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">url;<br>}

<p>-(MPMoviePlayerViewController <em>)moviePlayerViewController{<br>    </em></p></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_moviePlayerViewController) {<br>        NSURL url=[self getNetworkUrl];<br>        _moviePlayerViewController=[[MPMoviePlayerViewController alloc]initWithContentURL:url];<br>        [self addNotification];<br>    }<br>    </span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_moviePlayerViewController;<br>}<br></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - UI事件<p></p>
<ul>
<li>(IBAction)playClick:(UIButton *)sender {<br>  self.moviePlayerViewController=nil;</li></ul></span><span style="background: white; color: green">//保证每次点击都重新创建视频播放控制器视图，避免再次点击时由于不播放的问题<br>//    [self presentViewController:self.moviePlayerViewController animated:YES completion:nil];<br>  //注意，在MPMoviePlayerViewController.h中对UIViewController扩展两个用于模态展示和关闭MPMoviePlayerViewController的方法，增加了一种下拉展示动画效果<br>  </span><span style="background: white; color: black">[self presentMoviePlayerViewControllerAnimated:self.moviePlayerViewController];<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器通知<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>添加通知监控媒体播放控制器状态<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addNotification{<br>NSNotificationCenter notificationCenter=[NSNotificationCenter defaultCenter];<br>[notificationCenter addObserver:self selector:@selector(mediaPlayerPlaybackStateChange:) name:MPMoviePlayerPlaybackStateDidChangeNotification object:self.moviePlayerViewController.moviePlayer];<br>[notificationCenter addObserver:self selector:@selector(mediaPlayerPlaybackFinished:) name:MPMoviePlayerPlaybackDidFinishNotification object:self.moviePlayerViewController.moviePlayer];

<p>}</p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放状态改变，注意播放完成时的状态是暂停<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)mediaPlayerPlaybackStateChange:(NSNotification )notification{<br></span><span style="background: white; color: blue">switch </span><span style="background: white; color: black">(self.moviePlayerViewController.moviePlayer.playbackState) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMoviePlaybackStatePlaying:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;正在播放...&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMoviePlaybackStatePaused:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;暂停播放.&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;MPMoviePlaybackStateStopped:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;停止播放.&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;default&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;:
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;播放状态:%li&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,self.moviePlayerViewController.moviePlayer.playbackState);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放完成<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)mediaPlayerPlaybackFinished:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“播放完成.%li”</span><span style="background: white; color: black">,self.moviePlayerViewController.moviePlayer.playbackState);<br>}

<p>@end</p></span></pre><p></p>
<p></p><p>运行效果：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913431083055.gif" target="_blank" rel="external"><img title="MPMoviePlayerViewController" style="display: inline" alt="MPMoviePlayerViewController" src="http://images.cnitblog.com/blog/62046/201412/260913454994125.gif" width="320" height="594"></a></p><p></p>
<p></p><p>这里需要强调一下，由于MPMoviePlayerViewController的初始化方法做了大量工作（例如设置URL、自动播放、添加点击Done完成的监控等），所以当再次点击播放弹出新的模态窗口的时如果不销毁之前的MPMoviePlayerViewController，那么新的对象就无法完成初始化，这样也就不能再次进行播放。</p><p></p>
<p></p><h2 id="avPlayer">AVPlayer</h2><p></p>
<p></p><p>MPMoviePlayerController足够强大，几乎不用写几行代码就能完成一个播放器，但是正是由于它的高度封装使得要自定义这个播放器变得很复杂，甚至是不可能完成。例如有些时候需要自定义播放器的样式，那么如果要使用MPMoviePlayerController就不合适了，如果要对视频有自由的控制则可以使用AVPlayer。AVPlayer存在于AVFoundation中，它更加接近于底层，所以灵活性也更强：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913462492496.png" target="_blank" rel="external"><img title="AVFoundation_Framework" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="AVFoundation_Framework" src="http://images.cnitblog.com/blog/62046/201412/260913466409208.png" width="503" height="325"></a></p><p></p>
<p></p><p>AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。要使用AVPlayer首先了解一下几个常用的类：</p><p></p>
<p></p><p>AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。</p><p></p>
<p></p><p>AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。</p><p></p>
<p></p><p>AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。</p><p></p>
<p></p><p>下面简单通过一个播放器来演示AVPlayer的使用，播放器的效果如下：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260913472333095.png" target="_blank" rel="external"><img title="AVPlayer_Thumbnail" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="AVPlayer_Thumbnail" src="http://images.cnitblog.com/blog/62046/201412/260913485621122.png" width="320" height="568"></a></p><p></p>
<p></p><p>在这个自定义的播放器中实现了视频播放、暂停、进度展示和视频列表功能，下面将对这些功能一一介绍。</p><p></p>
<p></p><p>首先说一下视频的播放、暂停功能，这也是最基本的功能，AVPlayer对应着两个方法play、pause来实现。但是关键问题是如何判断当前视频是否在播放，在前面的内容中无论是音频播放器还是视频播放器都有对应的状态来判断，但是AVPlayer却没有这样的状态属性，通常情况下可以通过判断播放器的播放速度来获得播放状态。如果rate为0说明是停止状态，1是则是正常播放状态。</p><p></p>
<p></p><p>其次要展示播放进度就没有其他播放器那么简单了。在前面的播放器中通常是使用通知来获得播放器的状态，媒体加载状态等，但是无论是AVPlayer还是AVPlayerItem（AVPlayer有一个属性currentItem是AVPlayerItem类型，表示当前播放的视频对象）都无法获得这些信息。当然AVPlayerItem是有通知的，但是对于获得播放状态和加载状态有用的通知只有一个：播放完成通知AVPlayerItemDidPlayToEndTimeNotification。在播放视频时，特别是播放网络视频往往需要知道视频加载情况、缓冲情况、播放情况，这些信息可以通过KVO监控AVPlayerItem的status、loadedTimeRanges属性来获得。当AVPlayerItem的status属性为AVPlayerStatusReadyToPlay是说明正在播放，只有处于这个状态时才能获得视频时长等信息；当loadedTimeRanges的改变时（每缓冲一部分数据就会更新此属性）可以获得本次缓冲加载的视频范围（包含起始时间、本次加载时长），这样一来就可以实时获得缓冲情况。然后就是依靠AVPlayer的<strong>- (id)addPeriodicTimeObserverForInterval:(CMTime)interval queue:(dispatch_queue_t)queue usingBlock:(void (^)(CMTime time))block</strong>方法获得播放进度，这个方法会在设定的时间间隔内定时更新播放进度，通过time参数通知客户端。相信有了这些视频信息播放进度就不成问题了，事实上通过这些信息就算是平时看到的其他播放器的缓冲进度显示以及拖动播放的功能也可以顺利的实现。</p><p></p>
<p></p><p>最后就是视频切换的功能，在前面介绍的所有播放器中每个播放器对象一次只能播放一个视频，如果要切换视频只能重新创建一个对象，但是AVPlayer却提供了<strong>- (void)replaceCurrentItemWithPlayerItem:(AVPlayerItem *)item</strong>方法用于在不同的视频之间切换（事实上在AVFoundation内部还有一个AVQueuePlayer专门处理播放列表切换，有兴趣的朋友可以自行研究，这里不再赘述）。</p><p></p>
<p></p><p>下面附上代码：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  AVPlayer<br>//<br>//  Created by Kenshin Cui on 14/03/30.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AVFoundation/AVFoundation.h&gt;<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()<p></p>
<p>@</p></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(nonatomic,strong) AVPlayer *player;</span><span style="background: white; color: green">//播放器对象<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIView <em>container; </em></span><span style="background: white; color: green">//播放器容器<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton playOrPause; </span><span style="background: white; color: green">//播放/暂停按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIProgressView *progress;</span><span style="background: white; color: green">//播放进度<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器视图方法<p></p>
<ul>
<li>(</li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<br>  [self setupUI];<br>  [self.player play];<br>}

<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)dealloc{<br>    [self removeObserverFromPlayerItem:self.player.currentItem];<br>    [self removeNotification];<br>}<p></p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 私有方法<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setupUI{<br>    </span><span style="background: white; color: green">//创建播放器层<br>    </span><span style="background: white; color: black">AVPlayerLayer *playerLayer=[AVPlayerLayer playerLayerWithPlayer:self.player];<br>    playerLayer.frame=self.container.frame;<br>    </span><span style="background: white; color: green">//playerLayer.videoGravity=AVLayerVideoGravityResizeAspect;//视频填充模式<br>    </span><span style="background: white; color: black">[self.container.layer addSublayer:playerLayer];<br>}<p></p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>截取指定时间的视频缩略图<br>*</li>
<li>@param timeBySecond 时间点<br>*/</li>
</ul>
<p>/**</p>
<ul>
<li>初始化播放器<br>*</li>
<li>@return 播放器对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(AVPlayer )player{<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_player) {<pre><code>AVPlayerItem *playerItem=[self getPlayItem:0];
_player=[AVPlayer playerWithPlayerItem:playerItem];
[self addProgressObserver];
[self addObserverToPlayerItem:playerItem];
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">_player;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>根据视频索引取得AVPlayerItem对象<br>*</li>
<li>@param videoIndex 视频顺序索引<br>*</li>
<li>@return AVPlayerItem对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(AVPlayerItem )getPlayItem:(</span><span style="background: white; color: blue">int</span><span style="background: white; color: black">)videoIndex{<br>NSString <em>urlStr=[NSString stringWithFormat:@</em></span><span style="background: white; color: #a31515">“<a href="http://192.168.1.161/%i.mp4" target="_blank" rel="external">http://192.168.1.161/%i.mp4</a>“</span><span style="background: white; color: black">,videoIndex];<br>urlStr =[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];<br>NSURL url=[NSURL URLWithString:urlStr];<br>AVPlayerItem <em>playerItem=[AVPlayerItem playerItemWithURL:url];<br></em></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">playerItem;<br>}<br></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 通知<br></span><span style="background: white; color: green">/*
<li>添加播放器通知<br>*/<br></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addNotification{<br></span><span style="background: white; color: green">//给AVPlayerItem添加播放完成通知<br></span><span style="background: white; color: black">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playbackFinished:) name:AVPlayerItemDidPlayToEndTimeNotification object:self.player.currentItem];<br>}

<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)removeNotification{<br>    [[NSNotificationCenter defaultCenter] removeObserver:self];<br>}<p></p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>播放完成通知<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)playbackFinished:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“视频播放完成.”</span><span style="background: white; color: black">);<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 监控<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>给播放器添加进度更新<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addProgressObserver{<br>AVPlayerItem playerItem=self.player.currentItem;<br>UIProgressView *progress=self.progress;<br></span><span style="background: white; color: green">//这里设置每秒执行一次<br></span><span style="background: white; color: black">[self.player addPeriodicTimeObserverForInterval:CMTimeMake(1.0, 1.0) queue:dispatch_get_main_queue() usingBlock:^(CMTime time) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;float &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;current=CMTimeGetSeconds(time);
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;float &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;total=CMTimeGetSeconds([playerItem duration]);
NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;当前已经播放%.2fs.&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,current);
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(current) {
    [progress setProgress:(current/total) animated:YES];
}
</code></pre>}];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>给AVPlayerItem添加监控<br>*</li>
<li>@param playerItem AVPlayerItem对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addObserverToPlayerItem:(AVPlayerItem )playerItem{<br></span><span style="background: white; color: green">//监控状态属性，注意AVPlayer也有一个status属性，通过监控它的status也可以获得播放状态<br></span><span style="background: white; color: black">[playerItem addObserver:self forKeyPath:@</span><span style="background: white; color: #a31515">“status” </span><span style="background: white; color: black">options:NSKeyValueObservingOptionNew context:nil];<br></span><span style="background: white; color: green">//监控网络加载情况属性<br></span><span style="background: white; color: black">[playerItem addObserver:self forKeyPath:@</span><span style="background: white; color: #a31515">“loadedTimeRanges” </span><span style="background: white; color: black">options:NSKeyValueObservingOptionNew context:nil];<br>}<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)removeObserverFromPlayerItem:(AVPlayerItem <em>)playerItem{<br>[playerItem removeObserver:self forKeyPath:@</em></span><span style="background: white; color: #a31515">“status”</span><span style="background: white; color: black">];<br>[playerItem removeObserver:self forKeyPath:@</span><span style="background: white; color: #a31515">“loadedTimeRanges”</span><span style="background: white; color: black">];<br>}<br></span><span style="background: white; color: green">/*
<li>通过KVO监控播放器状态<br>*</li>
<li>@param keyPath 监控属性</li>
<li>@param object  监视器</li>
<li>@param change  状态改变</li>
<li>@param context 上下文<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(NSDictionary <em>)change context:(</em></span><span style="background: white; color: blue">void </span><span style="background: white; color: black">)context{<br>AVPlayerItem *playerItem=object;<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([keyPath isEqualToString:@</span><span style="background: white; color: #a31515">“status”</span><span style="background: white; color: black">]) {<pre><code>AVPlayerStatus status= [[change objectForKey:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;new&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] intValue];
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(status==AVPlayerStatusReadyToPlay){
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;正在播放...，视频总长度:%.2f&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,CMTimeGetSeconds(playerItem.duration));
}
</code></pre>}</span><span style="background: white; color: blue">else if</span><span style="background: white; color: black">([keyPath isEqualToString:@</span><span style="background: white; color: #a31515">“loadedTimeRanges”</span><span style="background: white; color: black">]){<pre><code>NSArray *&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;array&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;=playerItem.loadedTimeRanges;
CMTimeRange timeRange = [&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;array&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;.firstObject CMTimeRangeValue];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//本次缓冲时间范围
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;float &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;startSeconds = CMTimeGetSeconds(timeRange.start);
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;float &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;durationSeconds = CMTimeGetSeconds(timeRange.duration);
NSTimeInterval totalBuffer = startSeconds + durationSeconds;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//缓冲总长度
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;共缓冲：%.2f&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,totalBuffer);
</code></pre></span><span style="background: white; color: green">//<br></span><span style="background: white; color: black">}<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - UI事件<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>点击播放/暂停按钮<br>*</li>
<li>@param sender 播放/暂停按钮<br><em>/<br></em></li></ul></span><span style="background: white; color: black">- (IBAction)playClick:(UIButton )sender {<br></span><span style="background: white; color: green">//    AVPlayerItemDidPlayToEndTimeNotification<br>//AVPlayerItem *playerItem= self.player.currentItem;<br></span><span style="background: white; color: blue">if</span><span style="background: white; color: black">(self.player.rate==0){ </span><span style="background: white; color: green">//说明时暂停<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;player_pause&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateNormal];
[self.player play];
</code></pre>}</span><span style="background: white; color: blue">else if</span><span style="background: white; color: black">(self.player.rate==1){</span><span style="background: white; color: green">//正在播放<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;[self.player pause];
[sender setImage:[UIImage imageNamed:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;player_play&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;] forState:UIControlStateNormal];
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>切换选集，这里使用按钮的tag代表视频名称<br>*</li>
<li>@param sender 点击按钮对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">- (IBAction)navigationButtonClick:(UIButton )sender {<br>[self removeNotification];<br>[self removeObserverFromPlayerItem:self.player.currentItem];<br>AVPlayerItem *playerItem=[self getPlayItem:sender.tag];<br>[self addObserverToPlayerItem:playerItem];<br></span><span style="background: white; color: green">//切换视频<br></span><span style="background: white; color: black">[self.player replaceCurrentItemWithPlayerItem:playerItem];<br>[self addNotification];<br>}

<p>@end</p></span></pre><p></p>
<p></p><p>运行效果：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260914009836227.gif" target="_blank" rel="external"><img title="AVPlayer" style="display: inline" alt="AVPlayer" src="http://images.cnitblog.com/blog/62046/201412/260914169997701.gif" width="320" height="594"></a></p><p></p>
<p></p><p>到目前为止无论是MPMoviePlayerController还是AVPlayer来播放视频都相当强大，但是它也存在着一些不可回避的问题，那就是支持的视频编码格式很有限：H.264、MPEG-4，扩展名（压缩格式）：.mp4、.mov、.m4v、.m2v、.3gp、.3g2等。但是无论是MPMoviePlayerController还是AVPlayer它们都支持绝大多数音频编码，所以大家如果纯粹是为了播放音乐的话也可以考虑使用这两个播放器。那么如何支持更多视频编码格式呢？目前来说主要还是依靠第三方框架，在iOS上常用的视频编码、解码框架有：<a href="https://github.com/videolan/vlc" target="_blank" rel="external">VLC</a>、<a href="https://github.com/gabriel/ffmpeg-iphone-build" target="_blank" rel="external">ffmpeg</a>， 具体使用方式今天就不再做详细介绍。</p><p></p>
<p></p><h1 id="camera">摄像头</h1><p></p>
<p></p><h2 id="uiImagePickerController">UIImagePickerController拍照和视频录制</h2><p></p>
<p></p><p>下面看一下在iOS如何拍照和录制视频。在iOS中要拍照和录制视频最简单的方法就是使用UIImagePickerController。UIImagePickerController继承于UINavigationController，前面的文章中主要使用它来选取照片，其实UIImagePickerController的功能不仅如此，它还可以用来拍照和录制视频。首先看一下这个类常用的属性和方法：</p><p></p>
<p><table class="kc-table" cellspacing="0" cellpadding="0" width="800" border="0"></table></p>
<p><tbody></tbody></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">属性</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UIImagePickerControllerSourceType&nbsp;&nbsp;&nbsp;&nbsp; sourceType</td></p>
<p><td valign="top" width="400">拾取源类型，sourceType是枚举类型：<br>UIImagePickerControllerSourceTypePhotoLibrary：照片库<br>，默认值<br>UIImagePickerControllerSourceTypeCamera：摄像头<br>UIImagePickerControllerSourceTypeSavedPhotosAlbum：相簿</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic,copy)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *mediaTypes</td></p>
<p><td valign="top" width="400">媒体类型,默认情况下此数组包含kUTTypeImage，所以拍照时可以不用设置；但是当要录像的时候必须设置，可以设置为kUTTypeVideo（视频，但不带声音）或者kUTTypeMovie（视频并带有声音）</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSTimeInterval&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; videoMaximumDuration</td></p>
<p><td valign="top" width="400">视频最大录制时长，默认为10 s</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UIImagePickerControllerQualityType&nbsp;&nbsp;&nbsp; videoQuality</td></p>
<p><td valign="top" width="400">视频质量，枚举类型：<br>UIImagePickerControllerQualityTypeHigh：高清质量<br>UIImagePickerControllerQualityTypeMedium：中等质量，适合WiFi传输<br>UIImagePickerControllerQualityTypeLow：低质量，适合蜂窝网传输<br>UIImagePickerControllerQualityType640x480：640<em>480<br>UIImagePickerControllerQualityTypeIFrame1280x720：1280</em>720<br>UIImagePickerControllerQualityTypeIFrame960x540：960*540</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; showsCameraControls</td></p>
<p><td valign="top" width="400">是否显示摄像头控制面板，默认为YES</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic,retain)&nbsp;&nbsp;&nbsp; UIView&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *cameraOverlayView </td></p>
<p><td valign="top" width="400">摄像头上覆盖的视图，可用通过这个视频来自定义拍照或录像界面</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CGAffineTransform&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cameraViewTransform</td></p>
<p><td valign="top" width="400">摄像头形变</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic) UIImagePickerControllerCameraCaptureMode cameraCaptureMode</td></p>
<p><td valign="top" width="400">摄像头捕获模式，捕获模式是枚举类型：<br>UIImagePickerControllerCameraCaptureModePhoto：拍照模式<br>UIImagePickerControllerCameraCaptureModeVideo：视频录制模式</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic) UIImagePickerControllerCameraDevice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cameraDevice</td></p>
<p><td valign="top" width="400">摄像头设备，cameraDevice是枚举类型：<br>UIImagePickerControllerCameraDeviceRear：前置摄像头<br>UIImagePickerControllerCameraDeviceFront：后置摄像头</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">@property(nonatomic) UIImagePickerControllerCameraFlashMode&nbsp;&nbsp; cameraFlashMode </td></p>
<p><td valign="top" width="400">闪光灯模式，枚举类型：<br>UIImagePickerControllerCameraFlashModeOff：关闭闪光灯<br>UIImagePickerControllerCameraFlashModeAuto：闪光灯自动<br>UIImagePickerControllerCameraFlashModeOn：打开闪光灯</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">类方法</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">+ (BOOL)isSourceTypeAvailable:(UIImagePickerControllerSourceType)sourceType</td></p>
<p><td valign="top" width="400">指定的源类型是否可用，sourceType是枚举类型：<br>UIImagePickerControllerSourceTypePhotoLibrary：照片库<br>UIImagePickerControllerSourceTypeCamera：摄像头<br>UIImagePickerControllerSourceTypeSavedPhotosAlbum：相簿</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">+ (NSArray *)availableMediaTypesForSourceType:(UIImagePickerControllerSourceType)sourceType</td></p>
<p><td valign="top" width="400">指定的源设备上可用的媒体类型，一般就是图片和视频</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">+ (BOOL)isCameraDeviceAvailable:(UIImagePickerControllerCameraDevice)cameraDevice</td></p>
<p><td valign="top" width="400">指定的摄像头是否可用，cameraDevice是枚举类型：<br>UIImagePickerControllerCameraDeviceRear：前置摄像头<br>UIImagePickerControllerCameraDeviceFront：后置摄像头</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">+ (BOOL)isFlashAvailableForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice</td></p>
<p><td valign="top" width="400">指定摄像头的闪光灯是否可用</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">+ (NSArray *)availableCaptureModesForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice</td></p>
<p><td valign="top" width="400">获得指定摄像头上的可用捕获模式，捕获模式是枚举类型：<br>UIImagePickerControllerCameraCaptureModePhoto：拍照模式<br>UIImagePickerControllerCameraCaptureModeVideo：视频录制模式</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">对象方法</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)takePicture </td></p>
<p><td valign="top" width="400">编程方式拍照</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (BOOL)startVideoCapture </td></p>
<p><td valign="top" width="400">编程方式录制视频</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)stopVideoCapture</td></p>
<p><td valign="top" width="400">编程方式停止录制视频</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">代理方法</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)imagePickerController:(UIImagePickerController <em>)picker didFinishPickingMediaWithInfo:(NSDictionary </em>)info</td></p>
<p><td valign="top" width="400">媒体拾取完成</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker</td></p>
<p><td valign="top" width="400">取消拾取</td></p>
<p><tr class="subhead"></tr></p>
<p><td valign="top" width="400">扩展方法（主要用于保存照片、视频到相簿）</td></p>
<p><td valign="top" width="400">说明</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">UIImageWriteToSavedPhotosAlbum(UIImage <em>image, id completionTarget, SEL completionSelector, void </em>contextInfo)</td></p>
<p><td valign="top" width="400">保存照片到相簿</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(NSString *videoPath)</td></p>
<p><td valign="top" width="400">能否将视频保存到相簿</td></p>
<p><tr></tr></p>
<p><td valign="top" width="400">void UISaveVideoAtPathToSavedPhotosAlbum(NSString <em>videoPath, id completionTarget, SEL completionSelector, void </em>contextInfo)</td></p>
<p><td valign="top" width="400">保存视频到相簿</td></p>
<p></p><p>要用UIImagePickerController来拍照或者录制视频通常可以分为如下步骤：</p><p></p>
<p><ol></ol></p>
<p><li>创建UIImagePickerController对象。 </li></p>
<p><li>指定拾取源，平时选择照片时使用的拾取源是照片库或者相簿，此刻需要指定为摄像头类型。 </li></p>
<p><li>指定摄像头，前置摄像头或者后置摄像头。 </li></p>
<p><li>设置媒体类型mediaType，注意如果是录像必须设置，如果是拍照此步骤可以省略，因为mediaType默认包含kUTTypeImage（注意媒体类型定义在MobileCoreServices.framework中） </li></p>
<p><li>指定捕获模式，拍照或者录制视频。（视频录制时必须先设置媒体类型再设置捕获模式 </li></p>
<p><li>） </li></p>
<p><li>展示UIImagePickerController(通常以模态窗口形式打开）。 </li></p>
<p><li>拍照和录制视频结束后在代理方法中展示/保存照片或视频。</li></p>
<p></p><p>当然这个过程中有很多细节可以设置，例如是否显示拍照控制面板，拍照后是否允许编辑等等，通过上面的属性/方法列表相信并不难理解。下面就以一个示例展示如何使用UIImagePickerController来拍照和录制视频，下面的程序中只要将_isVideo设置为YES就是视频录制模式，录制完后在主视图控制器中自动播放；如果将_isVideo设置为NO则为拍照模式，拍照完成之后在主视图控制器中显示拍摄的照片：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  UIImagePickerController<br>//<br>//  Created by Kenshin Cui on 14/04/05.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//<p></p>
<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;MobileCoreServices/MobileCoreServices.h&gt;<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AVFoundation/AVFoundation.h&gt;<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()&lt;UIImagePickerControllerDelegate,UINavigationControllerDelegate&gt;<br>@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(assign,nonatomic) </span><span style="background: white; color: blue">int </span><span style="background: white; color: black">isVideo;</span><span style="background: white; color: green">//是否录制视频，如果为1表示录制视频，0代表拍照<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) UIImagePickerController <em>imagePicker;<br>@</em></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIImageView photo;</span><span style="background: white; color: green">//照片展示视图<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong ,nonatomic) AVPlayer *player;</span><span style="background: white; color: green">//播放器，用于录制完视频后播放视频<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器视图事件<p></p>
<ul>
<li>(</li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<br>  </span><span style="background: white; color: green">//通过这里设置当前程序是拍照还是录制视频<br>  </span><span style="background: white; color: black">_isVideo=YES;<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - UI事件<br></span><span style="background: white; color: green">//点击拍照按钮<br></span><span style="background: white; color: black">- (IBAction)takeClick:(UIButton *)sender {<br>    [self presentViewController:self.imagePicker animated:YES completion:nil];<br>}<p></p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - UIImagePickerController代理方法<br></span><span style="background: white; color: green">//完成<br></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)imagePickerController:(UIImagePickerController <em>)picker didFinishPickingMediaWithInfo:(NSDictionary </em>)info{<br>    NSString <em>mediaType=[info objectForKey:UIImagePickerControllerMediaType];<br>    </em></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([mediaType isEqualToString:(NSString )kUTTypeImage]) {</span><span style="background: white; color: green">//如果是拍照<br>        </span><span style="background: white; color: black">UIImage <em>image;<br>        </em></span><span style="background: white; color: green">//如果允许编辑则获得编辑后的照片，否则获取原始照片<br>        </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(self.imagePicker.allowsEditing) {<br>            image=[info objectForKey:UIImagePickerControllerEditedImage];</span><span style="background: white; color: green">//获取编辑后的照片<br>        </span><span style="background: white; color: black">}</span><span style="background: white; color: blue">else</span><span style="background: white; color: black">{<br>            image=[info objectForKey:UIImagePickerControllerOriginalImage];</span><span style="background: white; color: green">//获取原始照片<br>        </span><span style="background: white; color: black">}<br>        [self.photo setImage:image];</span><span style="background: white; color: green">//显示照片<br>        </span><span style="background: white; color: black">UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);</span><span style="background: white; color: green">//保存到相簿<br>    </span><span style="background: white; color: black">}</span><span style="background: white; color: blue">else if</span><span style="background: white; color: black">([mediaType isEqualToString:(NSString )kUTTypeMovie]){</span><span style="background: white; color: green">//如果是录制视频<br>        </span><span style="background: white; color: black">NSLog(@</span><span style="background: white; color: #a31515">“video…”</span><span style="background: white; color: black">);<br>        NSURL <em>url=[info objectForKey:UIImagePickerControllerMediaURL];</em></span><span style="background: white; color: green">//视频路径<br>        </span><span style="background: white; color: black">NSString urlStr=[url path];<br>        </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(urlStr)) {<br>            </span><span style="background: white; color: green">//保存视频到相簿，注意也可以使用ALAssetsLibrary来保存<br>            </span><span style="background: white; color: black">UISaveVideoAtPathToSavedPhotosAlbum(urlStr, self, @selector(video:didFinishSavingWithError:contextInfo:), nil);</span><span style="background: white; color: green">//保存视频到相簿<br>        </span><span style="background: white; color: black">}<p></p>
<pre><code>}

[self dismissViewControllerAnimated:YES completion:nil];
</code></pre><p>}<br>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)imagePickerControllerDidCancel:(UIImagePickerController *)picker{<br>    NSLog(@</span><span style="background: white; color: #a31515">“取消”</span><span style="background: white; color: black">);<br>}<p></p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 私有方法<br>-(UIImagePickerController <em>)imagePicker{<br>    </em></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!_imagePicker) {<br>        _imagePicker=[[UIImagePickerController alloc]init];<br>        _imagePicker.sourceType=UIImagePickerControllerSourceTypeCamera;</span><span style="background: white; color: green">//设置image picker的来源，这里设置为摄像头<br>        </span><span style="background: white; color: black">_imagePicker.cameraDevice=UIImagePickerControllerCameraDeviceRear;</span><span style="background: white; color: green">//设置使用哪个摄像头，这里设置为后置摄像头<br>        </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(self.isVideo) {<br>            _imagePicker.mediaTypes=@[(NSString )kUTTypeMovie];<br>            _imagePicker.videoQuality=UIImagePickerControllerQualityTypeIFrame1280x720;<br>            _imagePicker.cameraCaptureMode=UIImagePickerControllerCameraCaptureModeVideo;</span><span style="background: white; color: green">//设置摄像头模式（拍照，录制视频）<p></p>
<pre><code>    &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;else&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;{
        _imagePicker.cameraCaptureMode=UIImagePickerControllerCameraCaptureModePhoto;
    }
    _imagePicker.allowsEditing=YES;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//允许编辑
    &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_imagePicker.&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;delegate&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;=self;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//设置代理，检测操作
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_imagePicker;
</code></pre><p>}</p>
<p></p></span><span style="background: white; color: green">//视频保存后的回调<br></span><span style="background: white; color: black">- (</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)video:(NSString <em>)videoPath didFinishSavingWithError:(NSError </em>)error contextInfo:(</span><span style="background: white; color: blue">void </span><span style="background: white; color: black"><em>)contextInfo{<br>    </em></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(error) {<br>        NSLog(@</span><span style="background: white; color: #a31515">“保存视频过程中发生错误，错误信息:%@”</span><span style="background: white; color: black">,error.localizedDescription);<br>    }</span><span style="background: white; color: blue">else</span><span style="background: white; color: black">{<br>        NSLog(@</span><span style="background: white; color: #a31515">“视频保存成功.”</span><span style="background: white; color: black">);<br>        </span><span style="background: white; color: green">//录制完之后自动播放<br>        </span><span style="background: white; color: black">NSURL url=[NSURL fileURLWithPath:videoPath];<br>        _player=[AVPlayer playerWithURL:url];<br>        AVPlayerLayer *playerLayer=[AVPlayerLayer playerLayerWithPlayer:_player];<br>        playerLayer.frame=self.photo.frame;<br>        [self.photo.layer addSublayer:playerLayer];<br>        [_player play];<p></p>
<pre><code>}
</code></pre><p>}<br>@end</p></span></pre><p></p>
<p></p><p>运行效果（视频录制）：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260914246401667.png" target="_blank" rel="external"><img title="UIImagePickerController" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="UIImagePickerController" src="http://images.cnitblog.com/blog/62046/201412/260914290623149.png" width="320" height="568"></a></p><p></p>
<p></p><h2 id="avFoundationCamera">AVFoundation拍照和录制视频</h2><p></p>
<p></p><p>不得不说UIImagePickerController确实强大，但是与MPMoviePlayerController类似，由于它的高度封装性，要进行某些自定义工作就比较复杂了。例如要做出一款类似于美颜相机的拍照界面就比较难以实现了，此时就可以考虑使用AVFoundation来实现。AVFoundation中提供了很多现成的播放器和录音机，但是事实上它还有更加底层的内容可以供开发者使用。因为AVFoundation中抽了很多和底层输入、输出设备打交道的类，依靠这些类开发人员面对的不再是封装好的音频播放器AVAudioPlayer、录音机（AVAudioRecorder）、视频（包括音频）播放器AVPlayer，而是输入设备（例如麦克风、摄像头）、输出设备（图片、视频）等。首先了解一下使用AVFoundation做拍照和视频录制开发用到的相关类：</p><p></p>
<p></p><p><strong>AVCaptureSession</strong>：媒体（音、视频）捕获会话，负责把捕获的音视频数据输出到输出设备中。一个AVCaptureSession可以有多个输入输出：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260914316242934.png" target="_blank" rel="external"><img title="AVCaptureSession_InputAndOutput" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="AVCaptureSession_InputAndOutput" src="http://images.cnitblog.com/blog/62046/201412/260914332184945.png" width="562" height="323"></a></p><p></p>
<p></p><p><strong>AVCaptureDevice</strong>：输入设备，包括麦克风、摄像头，通过该对象可以设置物理设备的一些属性（例如相机聚焦、白平衡等）。</p><p></p>
<p></p><p><strong>AVCaptureDeviceInput</strong>：设备输入数据管理对象，可以根据AVCaptureDevice创建对应的AVCaptureDeviceInput对象，该对象将会被添加到AVCaptureSession中管理。</p><p></p>
<p></p><p><strong>AVCaptureOutput</strong>：输出数据管理对象，用于接收各类输出数据，通常使用对应的子类AVCaptureAudioDataOutput、AVCaptureStillImageOutput、AVCaptureVideoDataOutput、AVCaptureFileOutput，该对象将会被添加到AVCaptureSession中管理。注意：前面几个对象的输出数据都是NSData类型，而AVCaptureFileOutput代表数据以文件形式输出，类似的，AVCcaptureFileOutput也不会直接创建使用，通常会使用其子类：AVCaptureAudioFileOutput、AVCaptureMovieFileOutput。当把一个输入或者输出添加到AVCaptureSession之后AVCaptureSession就会在所有相符的输入、输出设备之间建立连接（AVCaptionConnection）：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260914343432502.png" target="_blank" rel="external"><img title="AVCaptureSession_Relation" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="AVCaptureSession_Relation" src="http://images.cnitblog.com/blog/62046/201412/260914350306359.png" width="583" height="427"></a></p><p></p>
<p></p><p><strong>AVCaptureVideoPreviewLayer</strong>：相机拍摄预览图层，是CALayer的子类，使用该对象可以实时查看拍照或视频录制效果，创建该对象需要指定对应的AVCaptureSession对象。</p><p></p>
<p></p><p>使用AVFoundation拍照和录制视频的一般步骤如下：</p><p></p>
<p><ol></ol></p>
<p><li>创建AVCaptureSession对象。 </li></p>
<p><li>使用AVCaptureDevice的静态方法获得需要使用的设备，例如拍照和录像就需要获得摄像头设备，录音就要获得麦克风设备。 </li></p>
<p><li>利用输入设备AVCaptureDevice初始化AVCaptureDeviceInput对象。 </li></p>
<p><li>初始化输出数据管理对象，如果要拍照就初始化AVCaptureStillImageOutput对象；如果拍摄视频就初始化AVCaptureMovieFileOutput对象。 </li></p>
<p><li>将数据输入对象AVCaptureDeviceInput、数据输出对象AVCaptureOutput添加到媒体会话管理对象AVCaptureSession中。 </li></p>
<p><li>创建视频预览图层AVCaptureVideoPreviewLayer并指定媒体会话，添加图层到显示容器中，调用AVCaptureSession的startRuning方法开始捕获。 </li></p>
<p><li>将捕获的音频或视频数据输出到指定文件。</li></p>
<p></p><h3>拍照</h3><p></p>
<p></p><p>下面看一下如何使用AVFoundation实现一个拍照程序，在这个程序中将实现摄像头预览、切换前后摄像头、闪光灯设置、对焦、拍照保存等功能。应用大致效果如下：</p><p></p>
<p></p><p><a href="http://images.cnitblog.com/blog/62046/201412/260914386088499.png" target="_blank" rel="external"><img title="AVFoundation_CameraRunEffect" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="AVFoundation_CameraRunEffect" src="http://images.cnitblog.com/blog/62046/201412/260914412966311.png" width="320" height="568"></a></p><p></p>
<p></p><p>在程序中定义会话、输入、输出等相关对象。</p><pre class="code"><span style="background: white; color: black">@</span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()<br>@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureSession <em>captureSession;</em></span><span style="background: white; color: green">//负责输入和输出设备之间的数据传递<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureDeviceInput captureDeviceInput;</span><span style="background: white; color: green">//负责从AVCaptureDevice获得输入数据<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureStillImageOutput <em>captureStillImageOutput;</em></span><span style="background: white; color: green">//照片输出流<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureVideoPreviewLayer captureVideoPreviewLayer;</span><span style="background: white; color: green">//相机拍摄预览图层<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIView <em>viewContainer;<br>@</em></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton takeButton;</span><span style="background: white; color: green">//拍照按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton <em>flashAutoButton;</em></span><span style="background: white; color: green">//自动闪光灯按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton flashOnButton;</span><span style="background: white; color: green">//打开闪光灯按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton <em>flashOffButton;</em></span><span style="background: white; color: green">//关闭闪光灯按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIImageView focusCursor; </span><span style="background: white; color: green">//聚焦光标<br></span><span style="background: white; color: black">@end</span></pre><p></p>
<p></p><p>在控制器视图将要展示时创建并初始化会话、摄像头设备、输入、输出、预览图层，并且添加预览图层到视图中，除此之外还做了一些初始化工作，例如添加手势（点击屏幕进行聚焦）、初始化界面等。</p><pre class="code"><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewWillAppear:(BOOL)animated{<br>    [super viewWillAppear:animated];<br>    </span><span style="background: white; color: green">//初始化会话<br>    </span><span style="background: white; color: black">_captureSession=[[AVCaptureSession alloc]init];<br>    </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([_captureSession canSetSessionPreset:AVCaptureSessionPreset1280x720]) {</span><span style="background: white; color: green">//设置分辨率<br>        </span><span style="background: white; color: black">_captureSession.sessionPreset=AVCaptureSessionPreset1280x720;<br>    }<br>    </span><span style="background: white; color: green">//获得输入设备<br>    </span><span style="background: white; color: black">AVCaptureDevice *captureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];</span><span style="background: white; color: green">//取得后置摄像头<br>    </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!captureDevice) {<br>        NSLog(@</span><span style="background: white; color: #a31515">“取得后置摄像头时出现问题.”</span><span style="background: white; color: black">);<br>        </span><span style="background: white; color: blue">return</span><span style="background: white; color: black">;<br>    }<p></p>
<pre><code>NSError *error=nil;
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//根据输入设备初始化设备输入对象，用于获得输入数据
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_captureDeviceInput=[[AVCaptureDeviceInput alloc]initWithDevice:captureDevice error:&amp;amp;error];
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(error) {
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;取得设备输入对象时出错，错误原因：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//初始化设备输出对象，用于获得输出数据
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_captureStillImageOutput=[[AVCaptureStillImageOutput alloc]init];
NSDictionary *outputSettings = @{AVVideoCodecKey:AVVideoCodecJPEG};
[_captureStillImageOutput setOutputSettings:outputSettings];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//输出设置

//将设备输入添加到会话中
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([_captureSession canAddInput:_captureDeviceInput]) {
    [_captureSession addInput:_captureDeviceInput];
}

&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//将设备输出添加到会话中
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([_captureSession canAddOutput:_captureStillImageOutput]) {
    [_captureSession addOutput:_captureStillImageOutput];
}

&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//创建视频预览层，用于实时展示摄像头状态
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_captureVideoPreviewLayer=[[AVCaptureVideoPreviewLayer alloc]initWithSession:self.captureSession];

CALayer *layer=self.viewContainer.layer;
layer.masksToBounds=YES;

_captureVideoPreviewLayer.frame=layer.bounds;
_captureVideoPreviewLayer.videoGravity=AVLayerVideoGravityResizeAspectFill;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//填充模式
//将视频预览层添加到界面中
//[layer addSublayer:_captureVideoPreviewLayer];
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;[layer insertSublayer:_captureVideoPreviewLayer below:self.focusCursor.layer];

[self addNotificationToCaptureDevice:captureDevice];
[self addGenstureRecognizer];
[self setFlashModeButtonStatus];
</code></pre><p>}</p></span></pre><p></p>
<p></p><p>在控制器视图展示和视图离开界面时启动、停止会话。</p><pre class="code"><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidAppear:(BOOL)animated{<br>    [super viewDidAppear:animated];<br>    [self.captureSession startRunning];<br>}<p></p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidDisappear:(BOOL)animated{<br>    [super viewDidDisappear:animated];<br>    [self.captureSession stopRunning];<br>}</span></pre><p></p>
<p></p><p>定义闪光灯开闭及自动模式功能，注意无论是设置闪光灯、白平衡还是其他输入设备属性，在设置之前必须先锁定配置，修改完后解锁。</p><pre class="code"><span style="background: white; color: green">/**<p></p>
<ul>
<li>改变设备属性的统一操作方法<br>*</li>
<li>@param propertyChange 属性改变操作<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)changeDeviceProperty:(PropertyChangeBlock)propertyChange{<br>AVCaptureDevice captureDevice= [self.captureDeviceInput device];<br>NSError *error;<br></span><span style="background: white; color: green">//注意改变设备属性前一定要首先调用lockForConfiguration:调用完之后使用unlockForConfiguration方法解锁<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([captureDevice lockForConfiguration:&amp;error]) {<pre><code>propertyChange(captureDevice);
[captureDevice unlockForConfiguration];
</code></pre>}</span><span style="background: white; color: blue">else</span><span style="background: white; color: black">{<pre><code>NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;设置设备属性过程发生错误，错误信息：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>设置闪光灯模式<br>*</li>
<li><p>@param flashMode 闪光灯模式<br><em>/<br></em></p></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setFlashMode:(AVCaptureFlashMode )flashMode{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<p></p>
<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFlashModeSupported:flashMode]) {
    [captureDevice setFlashMode:flashMode];
}
</code></pre><p>}];<br>}</p></span></pre><br><p>定义切换摄像头功能，切换摄像头的过程就是将原有输入移除，在会话中添加新的输入，但是注意动态修改会话需要首先开启配置，配置成功后提交配置。</p><pre class="code"><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark 切换前后摄像头<p></p>
<ul>
<li>(IBAction)toggleButtonClick:(UIButton <em>)sender {<br>AVCaptureDevice </em>currentDevice=[self.captureDeviceInput device];<br>AVCaptureDevicePosition currentPosition=[currentDevice position];<br>[self removeNotificationFromCaptureDevice:currentDevice];<br>AVCaptureDevice <em>toChangeDevice;<br>AVCaptureDevicePosition toChangePosition=AVCaptureDevicePositionFront;<br></em></li></ul></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(currentPosition==AVCaptureDevicePositionUnspecified||currentPosition==AVCaptureDevicePositionFront) {<br>  toChangePosition=AVCaptureDevicePositionBack;<br>}<br>toChangeDevice=[self getCameraDeviceWithPosition:toChangePosition];<br>[self addNotificationToCaptureDevice:toChangeDevice];<br></span><span style="background: white; color: green">//获得要调整的设备输入对象<br></span><span style="background: white; color: black">AVCaptureDeviceInput toChangeDeviceInput=[[AVCaptureDeviceInput alloc]initWithDevice:toChangeDevice error:nil];

<p></p></span><span style="background: white; color: green">//改变会话的配置前一定要先开启配置，配置完成后提交配置改变<br></span><span style="background: white; color: black">[self.captureSession beginConfiguration];<br></span><span style="background: white; color: green">//移除原有输入对象<br></span><span style="background: white; color: black">[self.captureSession removeInput:self.captureDeviceInput];<br></span><span style="background: white; color: green">//添加新的输入对象<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([self.captureSession canAddInput:toChangeDeviceInput]) {<p></p>
<pre><code>[self.captureSession addInput:toChangeDeviceInput];
self.captureDeviceInput=toChangeDeviceInput;
</code></pre><p>}<br></p></span><span style="background: white; color: green">//提交会话配置<br></span><span style="background: white; color: black">[self.captureSession commitConfiguration];<p></p>
<p>[self setFlashModeButtonStatus];<br>}</p></span></pre><br><p>添加点击手势操作，点按预览视图时进行聚焦、白平衡设置。</p><pre class="code"><span style="background: white; color: green">/**<p></p>

<li>设置聚焦点<br>*</li>
<li>@param point 聚焦点<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)focusWithMode:(AVCaptureFocusMode)focusMode exposureMode:(AVCaptureExposureMode)exposureMode atPoint:(CGPoint)point{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFocusModeSupported:focusMode]) {
    [captureDevice setFocusMode:AVCaptureFocusModeAutoFocus];
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFocusPointOfInterestSupported]) {
    [captureDevice setFocusPointOfInterest:point];
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isExposureModeSupported:exposureMode]) {
    [captureDevice setExposureMode:AVCaptureExposureModeAutoExpose];
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isExposurePointOfInterestSupported]) {
    [captureDevice setExposurePointOfInterest:point];
}
</code></pre>}];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li><p>添加点按手势，点按时聚焦<br><em>/<br></em></p></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addGenstureRecognizer{<br>UITapGestureRecognizer tapGesture=[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapScreen:)];<br>[self.viewContainer addGestureRecognizer:tapGesture];<br>}<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)tapScreen:(UITapGestureRecognizer *)tapGesture{<br>CGPoint point= [tapGesture locationInView:self.viewContainer];<br></span><span style="background: white; color: green">//将UI坐标转化为摄像头坐标<br></span><span style="background: white; color: black">CGPoint cameraPoint= [self.captureVideoPreviewLayer captureDevicePointOfInterestForPoint:point];<br>[self setFocusCursorWithPoint:point];<br>[self focusWithMode:AVCaptureFocusModeAutoFocus exposureMode:AVCaptureExposureModeAutoExpose atPoint:cameraPoint];<br>}</span></pre><br><p>定义拍照功能，拍照的过程就是获取连接，从连接中获得捕获的输出数据并做保存操作。</p><pre class="code"><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark 拍照<p></p>
<ul>
<li>(IBAction)takeButtonClick:(UIButton <em>)sender {<br></em></li></ul></span><span style="background: white; color: green">//根据设备输出获得连接<br></span><span style="background: white; color: black">AVCaptureConnection captureConnection=[self.captureStillImageOutput connectionWithMediaType:AVMediaTypeVideo];<br></span><span style="background: white; color: green">//根据连接取得设备输出的数据<br></span><span style="background: white; color: black">[self.captureStillImageOutput captureStillImageAsynchronouslyFromConnection:captureConnection completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) {<br>  </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(imageDataSampleBuffer) {<pre><code>  NSData *imageData=[AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer];
  UIImage *image=[UIImage imageWithData:imageData];
  UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);
</code></pre></span><span style="background: white; color: green">//            ALAssetsLibrary *assetsLibrary=[[ALAssetsLibrary alloc]init];<br>//            [assetsLibrary writeImageToSavedPhotosAlbum:[image CGImage] orientation:(ALAssetOrientation)[image imageOrientation] completionBlock:nil];<br>  </span><span style="background: white; color: black">}

<p>}];<br>}</p></span></pre><br><p>最后附上完整代码：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  AVFoundationCamera<br>//<br>//  Created by Kenshin Cui on 14/04/05.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//<p></p>


<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AVFoundation/AVFoundation.h&gt;<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AssetsLibrary/AssetsLibrary.h&gt;<br></span><span style="background: white; color: blue">typedef void</span><span style="background: white; color: black">(^PropertyChangeBlock)(AVCaptureDevice *captureDevice);<p></p>
<p>@</p></span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()<p></p>
<p>@</p></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureSession <em>captureSession;</em></span><span style="background: white; color: green">//负责输入和输出设备之间的数据传递<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureDeviceInput captureDeviceInput;</span><span style="background: white; color: green">//负责从AVCaptureDevice获得输入数据<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureStillImageOutput <em>captureStillImageOutput;</em></span><span style="background: white; color: green">//照片输出流<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureVideoPreviewLayer captureVideoPreviewLayer;</span><span style="background: white; color: green">//相机拍摄预览图层<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIView <em>viewContainer;<br>@</em></span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton takeButton;</span><span style="background: white; color: green">//拍照按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton <em>flashAutoButton;</em></span><span style="background: white; color: green">//自动闪光灯按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton flashOnButton;</span><span style="background: white; color: green">//打开闪光灯按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton <em>flashOffButton;</em></span><span style="background: white; color: green">//关闭闪光灯按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIImageView focusCursor; </span><span style="background: white; color: green">//聚焦光标<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器视图方法<p></p>
<ul>
<li>(</li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];

<p>}</p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewWillAppear:(BOOL)animated{<br>    [super viewWillAppear:animated];<br>    </span><span style="background: white; color: green">//初始化会话<br>    </span><span style="background: white; color: black">_captureSession=[[AVCaptureSession alloc]init];<br>    </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([_captureSession canSetSessionPreset:AVCaptureSessionPreset1280x720]) {</span><span style="background: white; color: green">//设置分辨率<br>        </span><span style="background: white; color: black">_captureSession.sessionPreset=AVCaptureSessionPreset1280x720;<br>    }<br>    </span><span style="background: white; color: green">//获得输入设备<br>    </span><span style="background: white; color: black">AVCaptureDevice *captureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];</span><span style="background: white; color: green">//取得后置摄像头<br>    </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!captureDevice) {<br>        NSLog(@</span><span style="background: white; color: #a31515">“取得后置摄像头时出现问题.”</span><span style="background: white; color: black">);<br>        </span><span style="background: white; color: blue">return</span><span style="background: white; color: black">;<br>    }<p></p>
<pre><code>NSError *error=nil;
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//根据输入设备初始化设备输入对象，用于获得输入数据
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_captureDeviceInput=[[AVCaptureDeviceInput alloc]initWithDevice:captureDevice error:&amp;amp;error];
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(error) {
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;取得设备输入对象时出错，错误原因：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//初始化设备输出对象，用于获得输出数据
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_captureStillImageOutput=[[AVCaptureStillImageOutput alloc]init];
NSDictionary *outputSettings = @{AVVideoCodecKey:AVVideoCodecJPEG};
[_captureStillImageOutput setOutputSettings:outputSettings];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//输出设置

//将设备输入添加到会话中
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([_captureSession canAddInput:_captureDeviceInput]) {
    [_captureSession addInput:_captureDeviceInput];
}

&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//将设备输出添加到会话中
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([_captureSession canAddOutput:_captureStillImageOutput]) {
    [_captureSession addOutput:_captureStillImageOutput];
}

&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//创建视频预览层，用于实时展示摄像头状态
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_captureVideoPreviewLayer=[[AVCaptureVideoPreviewLayer alloc]initWithSession:self.captureSession];

CALayer *layer=self.viewContainer.layer;
layer.masksToBounds=YES;

_captureVideoPreviewLayer.frame=layer.bounds;
_captureVideoPreviewLayer.videoGravity=AVLayerVideoGravityResizeAspectFill;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//填充模式
//将视频预览层添加到界面中
//[layer addSublayer:_captureVideoPreviewLayer];
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;[layer insertSublayer:_captureVideoPreviewLayer below:self.focusCursor.layer];

[self addNotificationToCaptureDevice:captureDevice];
[self addGenstureRecognizer];
[self setFlashModeButtonStatus];
</code></pre><p>}</p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidAppear:(BOOL)animated{<br>    [super viewDidAppear:animated];<br>    [self.captureSession startRunning];<br>}<p></p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidDisappear:(BOOL)animated{<br>    [super viewDidDisappear:animated];<br>    [self.captureSession stopRunning];<br>}<p></p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)dealloc{<br>    [self removeNotification];<br>}<br></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - UI方法<br></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark 拍照<p></p>
<ul>
<li><p>(IBAction)takeButtonClick:(UIButton <em>)sender {<br>  </em></p></li></ul></span><span style="background: white; color: green">//根据设备输出获得连接<br>  </span><span style="background: white; color: black">AVCaptureConnection captureConnection=[self.captureStillImageOutput connectionWithMediaType:AVMediaTypeVideo];<br>  </span><span style="background: white; color: green">//根据连接取得设备输出的数据<br>  </span><span style="background: white; color: black">[self.captureStillImageOutput captureStillImageAsynchronouslyFromConnection:captureConnection completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) {<p></p>
<pre><code>  &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(imageDataSampleBuffer) {
      NSData *imageData=[AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer];
      UIImage *image=[UIImage imageWithData:imageData];
      UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);
</code></pre><p></p></span><span style="background: white; color: green">//            ALAssetsLibrary *assetsLibrary=[[ALAssetsLibrary alloc]init];<br>//            [assetsLibrary writeImageToSavedPhotosAlbum:[image CGImage] orientation:(ALAssetOrientation)[image imageOrientation] completionBlock:nil];<p></p>
<pre><code>  &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;}
</code></pre><p>  }];<br>}<br></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark 切换前后摄像头<p></p>

<li><p>(IBAction)toggleButtonClick:(UIButton <em>)sender {<br>  AVCaptureDevice </em>currentDevice=[self.captureDeviceInput device];<br>  AVCaptureDevicePosition currentPosition=[currentDevice position];<br>  [self removeNotificationFromCaptureDevice:currentDevice];<br>  AVCaptureDevice *toChangeDevice;<br>  AVCaptureDevicePosition toChangePosition=AVCaptureDevicePositionFront;<br>  </p></li></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(currentPosition==AVCaptureDevicePositionUnspecified||currentPosition==AVCaptureDevicePositionFront) {<p></p>
<pre><code>  toChangePosition=AVCaptureDevicePositionBack;
</code></pre><p>  }<br>  toChangeDevice=[self getCameraDeviceWithPosition:toChangePosition];<br>  [self addNotificationToCaptureDevice:toChangeDevice];<br>  </p></span><span style="background: white; color: green">//获得要调整的设备输入对象<br>  </span><span style="background: white; color: black">AVCaptureDeviceInput *toChangeDeviceInput=[[AVCaptureDeviceInput alloc]initWithDevice:toChangeDevice error:nil];<p></p>
<p>  </p></span><span style="background: white; color: green">//改变会话的配置前一定要先开启配置，配置完成后提交配置改变<br>  </span><span style="background: white; color: black">[self.captureSession beginConfiguration];<br>  </span><span style="background: white; color: green">//移除原有输入对象<br>  </span><span style="background: white; color: black">[self.captureSession removeInput:self.captureDeviceInput];<br>  </span><span style="background: white; color: green">//添加新的输入对象<br>  </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([self.captureSession canAddInput:toChangeDeviceInput]) {<p></p>
<pre><code>  [self.captureSession addInput:toChangeDeviceInput];
  self.captureDeviceInput=toChangeDeviceInput;
</code></pre><p>  }<br>  </p></span><span style="background: white; color: green">//提交会话配置<br>  </span><span style="background: white; color: black">[self.captureSession commitConfiguration];<p></p>
<p>  [self setFlashModeButtonStatus];<br>}</p>


<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark 自动闪光灯开启<p></p>
<ul>
<li>(IBAction)flashAutoClick:(UIButton *)sender {<br>  [self setFlashMode:AVCaptureFlashModeAuto];<br>  [self setFlashModeButtonStatus];<br>}<br></li></ul></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark 打开闪光灯
<li>(IBAction)flashOnClick:(UIButton *)sender {<br>  [self setFlashMode:AVCaptureFlashModeOn];<br>  [self setFlashModeButtonStatus];<br>}<br></li></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark 关闭闪光灯
<li>(IBAction)flashOffClick:(UIButton *)sender {<br>  [self setFlashMode:AVCaptureFlashModeOff];<br>  [self setFlashModeButtonStatus];<br>}</li>

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 通知<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>给输入设备添加通知<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addNotificationToCaptureDevice:(AVCaptureDevice )captureDevice{<br></span><span style="background: white; color: green">//注意添加区域改变捕获通知必须首先设置设备允许捕获<br></span><span style="background: white; color: black">[self changeDeviceProperty:^(AVCaptureDevice *captureDevice) {<pre><code>captureDevice.subjectAreaChangeMonitoringEnabled=YES;
</code></pre>}];<br>NSNotificationCenter <em>notificationCenter= [NSNotificationCenter defaultCenter];<br></em></span><span style="background: white; color: green">//捕获区域发生改变<br></span><span style="background: white; color: black">[notificationCenter addObserver:self selector:@selector(areaChange:) name:AVCaptureDeviceSubjectAreaDidChangeNotification object:captureDevice];<br>}<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)removeNotificationFromCaptureDevice:(AVCaptureDevice )captureDevice{<br>NSNotificationCenter <em>notificationCenter= [NSNotificationCenter defaultCenter];<br>[notificationCenter removeObserver:self name:AVCaptureDeviceSubjectAreaDidChangeNotification object:captureDevice];<br>}<br></em></span><span style="background: white; color: green">/*
<li>移除所有通知<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)removeNotification{<br>NSNotificationCenter notificationCenter= [NSNotificationCenter defaultCenter];<br>[notificationCenter removeObserver:self];<br>}

<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addNotificationToCaptureSession:(AVCaptureSession <em>)captureSession{<br>    NSNotificationCenter </em>notificationCenter= [NSNotificationCenter defaultCenter];<br>    </span><span style="background: white; color: green">//会话出错<br>    </span><span style="background: white; color: black">[notificationCenter addObserver:self selector:@selector(sessionRuntimeError:) name:AVCaptureSessionRuntimeErrorNotification object:captureSession];<br>}<p></p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>设备连接成功<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)deviceConnected:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“设备已连接…”</span><span style="background: white; color: black">);<br>}<br></span><span style="background: white; color: green">/**
<li>设备连接断开<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)deviceDisconnected:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“设备已断开.”</span><span style="background: white; color: black">);<br>}<br></span><span style="background: white; color: green">/**
<li>捕获区域改变<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)areaChange:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“捕获区域改变…”</span><span style="background: white; color: black">);<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>会话出错<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)sessionRuntimeError:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“会话发生错误.”</span><span style="background: white; color: black">);<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 私有方法<p></p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得指定位置的摄像头<br>*</li>
<li>@param position 摄像头位置<br>*</li>
<li>@return 摄像头设备<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(AVCaptureDevice )getCameraDeviceWithPosition:(AVCaptureDevicePosition )position{<br>NSArray <em>cameras= [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo];<br></em></span><span style="background: white; color: blue">for </span><span style="background: white; color: black">(AVCaptureDevice camera in cameras) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([camera position]==position) {
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;camera;
}
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">nil;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>改变设备属性的统一操作方法<br>*</li>
<li>@param propertyChange 属性改变操作<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)changeDeviceProperty:(PropertyChangeBlock)propertyChange{<br>AVCaptureDevice captureDevice= [self.captureDeviceInput device];<br>NSError *error;<br></span><span style="background: white; color: green">//注意改变设备属性前一定要首先调用lockForConfiguration:调用完之后使用unlockForConfiguration方法解锁<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([captureDevice lockForConfiguration:&amp;error]) {<pre><code>propertyChange(captureDevice);
[captureDevice unlockForConfiguration];
</code></pre>}</span><span style="background: white; color: blue">else</span><span style="background: white; color: black">{<pre><code>NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;设置设备属性过程发生错误，错误信息：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>设置闪光灯模式<br>*</li>
<li>@param flashMode 闪光灯模式<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setFlashMode:(AVCaptureFlashMode )flashMode{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFlashModeSupported:flashMode]) {
    [captureDevice setFlashMode:flashMode];
}
</code></pre>}];<br>}<br></span><span style="background: white; color: green">/**
<li>设置聚焦模式<br>*</li>
<li>@param focusMode 聚焦模式<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setFocusMode:(AVCaptureFocusMode )focusMode{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFocusModeSupported:focusMode]) {
    [captureDevice setFocusMode:focusMode];
}
</code></pre>}];<br>}<br></span><span style="background: white; color: green">/**
<li>设置曝光模式<br>*</li>
<li>@param exposureMode 曝光模式<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setExposureMode:(AVCaptureExposureMode)exposureMode{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isExposureModeSupported:exposureMode]) {
    [captureDevice setExposureMode:exposureMode];
}
</code></pre>}];<br>}<br></span><span style="background: white; color: green">/**
<li>设置聚焦点<br>*</li>
<li>@param point 聚焦点<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)focusWithMode:(AVCaptureFocusMode)focusMode exposureMode:(AVCaptureExposureMode)exposureMode atPoint:(CGPoint)point{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFocusModeSupported:focusMode]) {
    [captureDevice setFocusMode:AVCaptureFocusModeAutoFocus];
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFocusPointOfInterestSupported]) {
    [captureDevice setFocusPointOfInterest:point];
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isExposureModeSupported:exposureMode]) {
    [captureDevice setExposureMode:AVCaptureExposureModeAutoExpose];
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isExposurePointOfInterestSupported]) {
    [captureDevice setExposurePointOfInterest:point];
}
</code></pre>}];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>添加点按手势，点按时聚焦<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addGenstureRecognizer{<br>UITapGestureRecognizer tapGesture=[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapScreen:)];<br>[self.viewContainer addGestureRecognizer:tapGesture];<br>}<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)tapScreen:(UITapGestureRecognizer *)tapGesture{<br>CGPoint point= [tapGesture locationInView:self.viewContainer];<br></span><span style="background: white; color: green">//将UI坐标转化为摄像头坐标<br></span><span style="background: white; color: black">CGPoint cameraPoint= [self.captureVideoPreviewLayer captureDevicePointOfInterestForPoint:point];<br>[self setFocusCursorWithPoint:point];<br>[self focusWithMode:AVCaptureFocusModeAutoFocus exposureMode:AVCaptureExposureModeAutoExpose atPoint:cameraPoint];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>设置闪光灯按钮状态<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setFlashModeButtonStatus{<br>AVCaptureDevice captureDevice=[self.captureDeviceInput device];<br>AVCaptureFlashMode flashMode=captureDevice.flashMode;<br></span><span style="background: white; color: blue">if</span><span style="background: white; color: black">([captureDevice isFlashAvailable]){<pre><code>self.flashAutoButton.hidden=NO;
self.flashOnButton.hidden=NO;
self.flashOffButton.hidden=NO;
self.flashAutoButton.enabled=YES;
self.flashOnButton.enabled=YES;
self.flashOffButton.enabled=YES;
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;switch &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(flashMode) {
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;AVCaptureFlashModeAuto:
        self.flashAutoButton.enabled=NO;
        &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;AVCaptureFlashModeOn:
        self.flashOnButton.enabled=NO;
        &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;case &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;AVCaptureFlashModeOff:
        self.flashOffButton.enabled=NO;
        &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;default&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;:
        &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
}
</code></pre>}</span><span style="background: white; color: blue">else</span><span style="background: white; color: black">{<pre><code>self.flashAutoButton.hidden=YES;
self.flashOnButton.hidden=YES;
self.flashOffButton.hidden=YES;
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>设置聚焦光标位置<br>*</li>
<li><p>@param point 光标位置<br>*/<br></p></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setFocusCursorWithPoint:(CGPoint)point{<br>self.focusCursor.center=point;<br>self.focusCursor.transform=CGAffineTransformMakeScale(1.5, 1.5);<br>self.focusCursor.alpha=1.0;<br>[UIView animateWithDuration:1.0 animations:^{<p></p>
<pre><code>self.focusCursor.transform=CGAffineTransformIdentity;
</code></pre><p>} completion:^(BOOL finished) {</p>
<pre><code>self.focusCursor.alpha=0;
</code></pre><p>}];<br>}<br>@end</p></span></pre><br><p>运行效果：</p><br><p><embed src="http://player.youku.com/player.php/sid/XODU2Njc5NjQ0/v.swf" allowfullscreen="true" quality="high" width="480" height="400" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"></p><br><h3>视频录制</h3><br><p>其实有了前面的拍照应用之后要在此基础上做视频录制功能并不复杂，程序只需要做如下修改：</p><br><ol><br><li>添加一个音频输入到会话（使用[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject]获得输入设备，然后根据此输入设备创建一个设备输入对象），在拍照程序中已经添加了视频输入所以此时不需要添加视频输入。<br></li><li>创建一个音乐播放文件输出对象AVCaptureMovieFileOutput取代原来的照片输出对象。<br></li><li>将捕获到的视频数据写入到临时文件并在停止录制之后保存到相簿（通过AVCaptureMovieFileOutput的代理方法）。</li></ol><br><p>相比拍照程序，程序的修改主要就是以上三点。当然为了让程序更加完善在下面的视频录制程序中加入了屏幕旋转视频、自动布局和后台保存任务等细节。下面是修改后的程序：</p><pre class="code"><span style="background: white; color: green">//<br>//  ViewController.m<br>//  AVFoundationCamera<br>//<br>//  Created by Kenshin Cui on 14/04/05.<br>//  Copyright (c) 2014年 cmjstudio. All rights reserved.<br>//  视频录制<p></p>


<p></p></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">“ViewController.h”<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AVFoundation/AVFoundation.h&gt;<br></span><span style="background: white; color: blue">#import </span><span style="background: white; color: #a31515">&lt;AssetsLibrary/AssetsLibrary.h&gt;<br></span><span style="background: white; color: blue">typedef void</span><span style="background: white; color: black">(^PropertyChangeBlock)(AVCaptureDevice *captureDevice);<p></p>
<p>@</p></span><span style="background: white; color: blue">interface </span><span style="background: white; color: black">ViewController ()&lt;AVCaptureFileOutputRecordingDelegate&gt;</span><span style="background: white; color: green">//视频文件输出代理<p></p>
<p></p></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureSession <em>captureSession;</em></span><span style="background: white; color: green">//负责输入和输出设备之间的数据传递<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureDeviceInput captureDeviceInput;</span><span style="background: white; color: green">//负责从AVCaptureDevice获得输入数据<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureMovieFileOutput <em>captureMovieFileOutput;</em></span><span style="background: white; color: green">//视频输出流<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(strong,nonatomic) AVCaptureVideoPreviewLayer captureVideoPreviewLayer;</span><span style="background: white; color: green">//相机拍摄预览图层<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(assign,nonatomic) BOOL enableRotation;</span><span style="background: white; color: green">//是否允许旋转（注意在视频录制过程中禁止屏幕旋转）<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(assign,nonatomic) CGRect <em>lastBounds;</em></span><span style="background: white; color: green">//旋转的前大小<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(assign,nonatomic) UIBackgroundTaskIdentifier backgroundTaskIdentifier;</span><span style="background: white; color: green">//后台任务标识<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIView viewContainer;<br>@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIButton <em>takeButton;</em></span><span style="background: white; color: green">//拍照按钮<br></span><span style="background: white; color: black">@</span><span style="background: white; color: blue">property </span><span style="background: white; color: black">(weak, nonatomic) IBOutlet UIImageView focusCursor; </span><span style="background: white; color: green">//聚焦光标<p></p>
<p></p></span><span style="background: white; color: black">@end<p></p>
<p>@implementation ViewController</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 控制器视图方法<p></p>
<ul>
<li>(</li></ul></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidLoad {<br>  [super viewDidLoad];<br>}

<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewWillAppear:(BOOL)animated{<br>    [super viewWillAppear:animated];<br>    </span><span style="background: white; color: green">//初始化会话<br>    </span><span style="background: white; color: black">_captureSession=[[AVCaptureSession alloc]init];<br>    </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([_captureSession canSetSessionPreset:AVCaptureSessionPreset1280x720]) {</span><span style="background: white; color: green">//设置分辨率<br>        </span><span style="background: white; color: black">_captureSession.sessionPreset=AVCaptureSessionPreset1280x720;<br>    }<br>    </span><span style="background: white; color: green">//获得输入设备<br>    </span><span style="background: white; color: black">AVCaptureDevice <em>captureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];</em></span><span style="background: white; color: green">//取得后置摄像头<br>    </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(!captureDevice) {<br>        NSLog(@</span><span style="background: white; color: #a31515">“取得后置摄像头时出现问题.”</span><span style="background: white; color: black">);<br>        </span><span style="background: white; color: blue">return</span><span style="background: white; color: black">;<br>    }<br>    </span><span style="background: white; color: green">//添加一个音频输入设备<br>    </span><span style="background: white; color: black">AVCaptureDevice audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];<p></p>
<pre><code>NSError *error=nil;
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//根据输入设备初始化设备输入对象，用于获得输入数据
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_captureDeviceInput=[[AVCaptureDeviceInput alloc]initWithDevice:captureDevice error:&amp;amp;error];
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(error) {
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;取得设备输入对象时出错，错误原因：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
}
AVCaptureDeviceInput *audioCaptureDeviceInput=[[AVCaptureDeviceInput alloc]initWithDevice:audioCaptureDevice error:&amp;amp;error];
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;(error) {
    NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;取得设备输入对象时出错，错误原因：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;;
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//初始化设备输出对象，用于获得输出数据
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_captureMovieFileOutput=[[AVCaptureMovieFileOutput alloc]init];

&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//将设备输入添加到会话中
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([_captureSession canAddInput:_captureDeviceInput]) {
    [_captureSession addInput:_captureDeviceInput];
    [_captureSession addInput:audioCaptureDeviceInput];
    AVCaptureConnection *captureConnection=[_captureMovieFileOutput connectionWithMediaType:AVMediaTypeVideo];
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureConnection isVideoStabilizationSupported ]) {
        captureConnection.preferredVideoStabilizationMode=AVCaptureVideoStabilizationModeAuto;
    }
}

&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//将设备输出添加到会话中
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([_captureSession canAddOutput:_captureMovieFileOutput]) {
    [_captureSession addOutput:_captureMovieFileOutput];
}

&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//创建视频预览层，用于实时展示摄像头状态
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;_captureVideoPreviewLayer=[[AVCaptureVideoPreviewLayer alloc]initWithSession:self.captureSession];

CALayer *layer=self.viewContainer.layer;
layer.masksToBounds=YES;

_captureVideoPreviewLayer.frame=layer.bounds;
_captureVideoPreviewLayer.videoGravity=AVLayerVideoGravityResizeAspectFill;&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//填充模式
//将视频预览层添加到界面中
//[layer addSublayer:_captureVideoPreviewLayer];
&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;[layer insertSublayer:_captureVideoPreviewLayer below:self.focusCursor.layer];

_enableRotation=YES;
[self addNotificationToCaptureDevice:captureDevice];
[self addGenstureRecognizer];
</code></pre><p>}</p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidAppear:(BOOL)animated{<br>    [super viewDidAppear:animated];<br>    [self.captureSession startRunning];<br>}<p></p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)viewDidDisappear:(BOOL)animated{<br>    [super viewDidDisappear:animated];<br>    [self.captureSession stopRunning];<br>}<p></p>
<p>-(BOOL)shouldAutorotate{<br>    </p></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">self.enableRotation;<br>}<p></p>
<p></p></span><span style="background: white; color: green">////屏幕旋转时调整视频预览图层的方向<br>//-(void)willTransitionToTraitCollection:(UITraitCollection <em>)newCollection withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator{<br>//    [super willTransitionToTraitCollection:newCollection withTransitionCoordinator:coordinator];<br>////    NSLog(@”%i,%i”,newCollection.verticalSizeClass,newCollection.horizontalSizeClass);<br>//    UIInterfaceOrientation orientation = [[UIApplication sharedApplication] statusBarOrientation];<br>//    NSLog(@”%i”,orientation);<br>//    AVCaptureConnection </em>captureConnection=[self.captureVideoPreviewLayer connection];<br>//    captureConnection.videoOrientation=orientation;<br>//<br>//}<br>//屏幕旋转时调整视频预览图层的方向<br></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration{<br>    AVCaptureConnection *captureConnection=[self.captureVideoPreviewLayer connection];<br>    captureConnection.videoOrientation=(AVCaptureVideoOrientation)toInterfaceOrientation;<br>}<br></span><span style="background: white; color: green">//旋转后重新设置大小<br></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation{<br>    _captureVideoPreviewLayer.frame=self.viewContainer.bounds;<br>}<p></p>
<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)dealloc{<br>    [self removeNotification];<br>}<br></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - UI方法<br></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark 视频录制<p></p>
<ul>
<li>(IBAction)takeButtonClick:(UIButton <em>)sender {<br>  </em></li></ul></span><span style="background: white; color: green">//根据设备输出获得连接<br>  </span><span style="background: white; color: black">AVCaptureConnection captureConnection=[self.captureMovieFileOutput connectionWithMediaType:AVMediaTypeVideo];<br>  </span><span style="background: white; color: green">//根据连接取得设备输出的数据<br>  </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(![self.captureMovieFileOutput isRecording]) {<pre><code>  self.enableRotation=NO;
  &lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//如果支持多任务则则开始多任务
  &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([[UIDevice currentDevice] isMultitaskingSupported]) {
      self.backgroundTaskIdentifier=[[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:nil];
  }
  &lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//预览图层和视频方向保持一致
  &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;captureConnection.videoOrientation=[self.captureVideoPreviewLayer connection].videoOrientation;
  NSString *outputFielPath=[NSTemporaryDirectory() stringByAppendingString:@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;myMovie.mov&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;];
  NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;save path is :%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,outputFielPath);
  NSURL *fileUrl=[NSURL fileURLWithPath:outputFielPath];
  [self.captureMovieFileOutput startRecordingToOutputFileURL:fileUrl recordingDelegate:self];
</code></pre>  }<br>  </span><span style="background: white; color: blue">else</span><span style="background: white; color: black">{<pre><code>  [self.captureMovieFileOutput stopRecording];&lt;/span&gt;&lt;span style=&quot;background: white; color: green&quot;&gt;//停止录制
</code></pre>  </span><span style="background: white; color: black">}<br>}<br></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark 切换前后摄像头
<li><p>(IBAction)toggleButtonClick:(UIButton <em>)sender {<br>  AVCaptureDevice </em>currentDevice=[self.captureDeviceInput device];<br>  AVCaptureDevicePosition currentPosition=[currentDevice position];<br>  [self removeNotificationFromCaptureDevice:currentDevice];<br>  AVCaptureDevice *toChangeDevice;<br>  AVCaptureDevicePosition toChangePosition=AVCaptureDevicePositionFront;<br>  </p></li></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(currentPosition==AVCaptureDevicePositionUnspecified||currentPosition==AVCaptureDevicePositionFront) {<p></p>
<pre><code>  toChangePosition=AVCaptureDevicePositionBack;
</code></pre><p>  }<br>  toChangeDevice=[self getCameraDeviceWithPosition:toChangePosition];<br>  [self addNotificationToCaptureDevice:toChangeDevice];<br>  </p></span><span style="background: white; color: green">//获得要调整的设备输入对象<br>  </span><span style="background: white; color: black">AVCaptureDeviceInput *toChangeDeviceInput=[[AVCaptureDeviceInput alloc]initWithDevice:toChangeDevice error:nil];<p></p>
<p>  </p></span><span style="background: white; color: green">//改变会话的配置前一定要先开启配置，配置完成后提交配置改变<br>  </span><span style="background: white; color: black">[self.captureSession beginConfiguration];<br>  </span><span style="background: white; color: green">//移除原有输入对象<br>  </span><span style="background: white; color: black">[self.captureSession removeInput:self.captureDeviceInput];<br>  </span><span style="background: white; color: green">//添加新的输入对象<br>  </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([self.captureSession canAddInput:toChangeDeviceInput]) {<p></p>
<pre><code>  [self.captureSession addInput:toChangeDeviceInput];
  self.captureDeviceInput=toChangeDeviceInput;
</code></pre><p>  }<br>  </p></span><span style="background: white; color: green">//提交会话配置<br>  </span><span style="background: white; color: black">[self.captureSession commitConfiguration];<p></p>


<p>}</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 视频输出代理<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)captureOutput:(AVCaptureFileOutput <em>)captureOutput didStartRecordingToOutputFileAtURL:(NSURL </em>)fileURL fromConnections:(NSArray <em>)connections{<br>    NSLog(@</em></span><span style="background: white; color: #a31515">“开始录制…”</span><span style="background: white; color: black">);<br>}<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)captureOutput:(AVCaptureFileOutput )captureOutput didFinishRecordingToOutputFileAtURL:(NSURL <em>)outputFileURL fromConnections:(NSArray </em>)connections error:(NSError <em>)error{<br>    NSLog(@</em></span><span style="background: white; color: #a31515">“视频录制完成.”</span><span style="background: white; color: black">);<br>    </span><span style="background: white; color: green">//视频录入完成之后在后台将视频存储到相簿<br>    </span><span style="background: white; color: black">self.enableRotation=YES;<br>    UIBackgroundTaskIdentifier lastBackgroundTaskIdentifier=self.backgroundTaskIdentifier;<br>    self.backgroundTaskIdentifier=UIBackgroundTaskInvalid;<br>    ALAssetsLibrary assetsLibrary=[[ALAssetsLibrary alloc]init];<br>    [assetsLibrary writeVideoAtPathToSavedPhotosAlbum:outputFileURL completionBlock:^(NSURL <em>assetURL, NSError </em>error) {<br>        </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(error) {<br>            NSLog(@</span><span style="background: white; color: #a31515">“保存视频到相簿过程中发生错误，错误信息：%@”</span><span style="background: white; color: black">,error.localizedDescription);<br>        }<br>        </span><span style="background: white; color: blue">if </span><span style="background: white; color: black">(lastBackgroundTaskIdentifier!=UIBackgroundTaskInvalid) {<br>            [[UIApplication sharedApplication] endBackgroundTask:lastBackgroundTaskIdentifier];<br>        }<br>        NSLog(@</span><span style="background: white; color: #a31515">“成功保存视频到相簿.”</span><span style="background: white; color: black">);<br>    }];<p></p>
<p>}</p>
<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 通知<br></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>给输入设备添加通知<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addNotificationToCaptureDevice:(AVCaptureDevice )captureDevice{<br></span><span style="background: white; color: green">//注意添加区域改变捕获通知必须首先设置设备允许捕获<br></span><span style="background: white; color: black">[self changeDeviceProperty:^(AVCaptureDevice *captureDevice) {<pre><code>captureDevice.subjectAreaChangeMonitoringEnabled=YES;
</code></pre>}];<br>NSNotificationCenter <em>notificationCenter= [NSNotificationCenter defaultCenter];<br></em></span><span style="background: white; color: green">//捕获区域发生改变<br></span><span style="background: white; color: black">[notificationCenter addObserver:self selector:@selector(areaChange:) name:AVCaptureDeviceSubjectAreaDidChangeNotification object:captureDevice];<br>}<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)removeNotificationFromCaptureDevice:(AVCaptureDevice )captureDevice{<br>NSNotificationCenter <em>notificationCenter= [NSNotificationCenter defaultCenter];<br>[notificationCenter removeObserver:self name:AVCaptureDeviceSubjectAreaDidChangeNotification object:captureDevice];<br>}<br></em></span><span style="background: white; color: green">/*
<li>移除所有通知<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)removeNotification{<br>NSNotificationCenter notificationCenter= [NSNotificationCenter defaultCenter];<br>[notificationCenter removeObserver:self];<br>}

<p>-(</p></span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addNotificationToCaptureSession:(AVCaptureSession <em>)captureSession{<br>    NSNotificationCenter </em>notificationCenter= [NSNotificationCenter defaultCenter];<br>    </span><span style="background: white; color: green">//会话出错<br>    </span><span style="background: white; color: black">[notificationCenter addObserver:self selector:@selector(sessionRuntimeError:) name:AVCaptureSessionRuntimeErrorNotification object:captureSession];<br>}<p></p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>设备连接成功<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)deviceConnected:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“设备已连接…”</span><span style="background: white; color: black">);<br>}<br></span><span style="background: white; color: green">/**
<li>设备连接断开<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)deviceDisconnected:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“设备已断开.”</span><span style="background: white; color: black">);<br>}<br></span><span style="background: white; color: green">/**
<li>捕获区域改变<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)areaChange:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“捕获区域改变…”</span><span style="background: white; color: black">);<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>会话出错<br>*</li>
<li>@param notification 通知对象<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)sessionRuntimeError:(NSNotification )notification{<br>NSLog(@</span><span style="background: white; color: #a31515">“会话发生错误.”</span><span style="background: white; color: black">);<br>}

<p></p></span><span style="background: white; color: blue">#pragma </span><span style="background: white; color: black">mark - 私有方法<p></p>
<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>取得指定位置的摄像头<br>*</li>
<li>@param position 摄像头位置<br>*</li>
<li>@return 摄像头设备<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(AVCaptureDevice )getCameraDeviceWithPosition:(AVCaptureDevicePosition )position{<br>NSArray <em>cameras= [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo];<br></em></span><span style="background: white; color: blue">for </span><span style="background: white; color: black">(AVCaptureDevice camera in cameras) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([camera position]==position) {
    &lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;camera;
}
</code></pre>}<br></span><span style="background: white; color: blue">return </span><span style="background: white; color: black">nil;<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>改变设备属性的统一操作方法<br>*</li>
<li>@param propertyChange 属性改变操作<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)changeDeviceProperty:(PropertyChangeBlock)propertyChange{<br>AVCaptureDevice captureDevice= [self.captureDeviceInput device];<br>NSError *error;<br></span><span style="background: white; color: green">//注意改变设备属性前一定要首先调用lockForConfiguration:调用完之后使用unlockForConfiguration方法解锁<br></span><span style="background: white; color: blue">if </span><span style="background: white; color: black">([captureDevice lockForConfiguration:&amp;error]) {<pre><code>propertyChange(captureDevice);
[captureDevice unlockForConfiguration];
</code></pre>}</span><span style="background: white; color: blue">else</span><span style="background: white; color: black">{<pre><code>NSLog(@&lt;/span&gt;&lt;span style=&quot;background: white; color: #a31515&quot;&gt;&quot;设置设备属性过程发生错误，错误信息：%@&quot;&lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;,error.localizedDescription);
</code></pre>}<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>设置闪光灯模式<br>*</li>
<li>@param flashMode 闪光灯模式<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setFlashMode:(AVCaptureFlashMode )flashMode{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFlashModeSupported:flashMode]) {
    [captureDevice setFlashMode:flashMode];
}
</code></pre>}];<br>}<br></span><span style="background: white; color: green">/**
<li>设置聚焦模式<br>*</li>
<li>@param focusMode 聚焦模式<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setFocusMode:(AVCaptureFocusMode )focusMode{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFocusModeSupported:focusMode]) {
    [captureDevice setFocusMode:focusMode];
}
</code></pre>}];<br>}<br></span><span style="background: white; color: green">/**
<li>设置曝光模式<br>*</li>
<li>@param exposureMode 曝光模式<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setExposureMode:(AVCaptureExposureMode)exposureMode{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isExposureModeSupported:exposureMode]) {
    [captureDevice setExposureMode:exposureMode];
}
</code></pre>}];<br>}<br></span><span style="background: white; color: green">/**
<li>设置聚焦点<br>*</li>
<li>@param point 聚焦点<br><em>/<br></em></li></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)focusWithMode:(AVCaptureFocusMode)focusMode exposureMode:(AVCaptureExposureMode)exposureMode atPoint:(CGPoint)point{<br>[self changeDeviceProperty:^(AVCaptureDevice captureDevice) {<pre><code>&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFocusModeSupported:focusMode]) {
    [captureDevice setFocusMode:AVCaptureFocusModeAutoFocus];
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isFocusPointOfInterestSupported]) {
    [captureDevice setFocusPointOfInterest:point];
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isExposureModeSupported:exposureMode]) {
    [captureDevice setExposureMode:AVCaptureExposureModeAutoExpose];
}
&lt;/span&gt;&lt;span style=&quot;background: white; color: blue&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;background: white; color: black&quot;&gt;([captureDevice isExposurePointOfInterestSupported]) {
    [captureDevice setExposurePointOfInterest:point];
}
</code></pre>}];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>添加点按手势，点按时聚焦<br><em>/<br></em></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)addGenstureRecognizer{<br>UITapGestureRecognizer tapGesture=[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapScreen:)];<br>[self.viewContainer addGestureRecognizer:tapGesture];<br>}<br>-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)tapScreen:(UITapGestureRecognizer *)tapGesture{<br>CGPoint point= [tapGesture locationInView:self.viewContainer];<br></span><span style="background: white; color: green">//将UI坐标转化为摄像头坐标<br></span><span style="background: white; color: black">CGPoint cameraPoint= [self.captureVideoPreviewLayer captureDevicePointOfInterestForPoint:point];<br>[self setFocusCursorWithPoint:point];<br>[self focusWithMode:AVCaptureFocusModeAutoFocus exposureMode:AVCaptureExposureModeAutoExpose atPoint:cameraPoint];<br>}

<p></p></span><span style="background: white; color: green">/**<p></p>
<ul>
<li>设置聚焦光标位置<br>*</li>
<li><p>@param point 光标位置<br>*/<br></p></li></ul></span><span style="background: white; color: black">-(</span><span style="background: white; color: blue">void</span><span style="background: white; color: black">)setFocusCursorWithPoint:(CGPoint)point{<br>self.focusCursor.center=point;<br>self.focusCursor.transform=CGAffineTransformMakeScale(1.5, 1.5);<br>self.focusCursor.alpha=1.0;<br>[UIView animateWithDuration:1.0 animations:^{<p></p>
<pre><code>self.focusCursor.transform=CGAffineTransformIdentity;
</code></pre><p>} completion:^(BOOL finished) {</p>
<pre><code>self.focusCursor.alpha=0;
</code></pre><p>}];<br>}<br>@end</p></span></pre><br><p>运行效果：</p><br><p><embed src="http://player.youku.com/player.php/sid/XODU2NjgwMjI4/v.swf" allowfullscreen="true" quality="high" width="480" height="400" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"></p><br><h1 id="summary">总结</h1><br><p>前面用了大量的篇幅介绍了iOS中的音、视频播放和录制，有些地方用到了封装好的播放器、录音机直接使用，有些是直接调用系统服务自己组织封装，正如本篇开头所言，iOS对于多媒体支持相当灵活和完善，那么开放过程中如何选择呢，下面就以一个表格简单对比一下各个开发技术的优缺点。</p><br><p><a href="http://images.cnitblog.com/blog/62046/201412/260914422024869.png" target="_blank" rel="external"><img title="summary" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="summary" src="http://images.cnitblog.com/blog/62046/201412/260914428126282.png" width="775" height="497"></a></p><p></p>
<blockquote><br><p>提示：从本文及以后的文章中可能慢慢使用storyboard或xib，原因如下：1.苹果官方目前主推storyboard;2.后面的文章中做屏幕适配牵扯到很多内容都是storyboard中进行（尽管纯代码也可以实现，但是纯代码对autolayout支持不太好）3.通过前面的一系列文章大家对于纯代码编程应该已经有一定的积累了（纯代码确实可以另初学者更加了解程序运行原理）。</p></blockquote>



</span>
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/07/20/webView图片自适应屏幕/" rel="next" title="webView图片自适应屏幕">
                <i class="fa fa-chevron-left"></i> webView图片自适应屏幕
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/10/20/怎么在极光推送给APP建立推送服务器/" rel="prev" title="怎么在极光推送给APP建立推送服务器">
                怎么在极光推送给APP建立推送服务器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2015/09/02/iOS开发之音视频播放录制/"
     data-title="iOS开发之音视频播放录制"
     data-content=""
     data-url="http://yoursite.com/2015/09/02/iOS开发之音视频播放录制/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


        </div>

        

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


        
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2015/09/02/iOS开发之音视频播放录制/"
           data-title="iOS开发之音视频播放录制" data-url="http://yoursite.com/2015/09/02/iOS开发之音视频播放录制/">
      </div>
    
  </div>


      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://img5.duitang.com/uploads/item/201406/26/20140626193943_WGW2n.thumb.700_0.jpeg" alt="YCK" itemprop="image"/>
          <p class="site-author-name" itemprop="name">YCK</p>
        </div>
        <p class="site-description motion-element" itemprop="description">愿世界永无Bug！</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">36</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yckblog/ykcoder" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/fav?leftnav=1" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#audio"><span class="nav-number">2.</span> <span class="nav-text">音频</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#soundEffect"><span class="nav-number">2.1.</span> <span class="nav-text">音效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#music"><span class="nav-number">2.2.</span> <span class="nav-text">音乐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#audioSession"><span class="nav-number">2.3.</span> <span class="nav-text">音频会话</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.3.1.</span> <span class="nav-text">扩展–播放音乐库中的音乐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#audioRecord"><span class="nav-number">2.4.</span> <span class="nav-text">录音</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#audioQueueServices"><span class="nav-number">2.5.</span> <span class="nav-text">音频队列服务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#video"><span class="nav-number">3.</span> <span class="nav-text">视频</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mpMoviePlayerController"><span class="nav-number">3.1.</span> <span class="nav-text">MPMoviePlayerController</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.1.1.</span> <span class="nav-text">扩展–使用AVFoundation生成缩略图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mpMoviePlayerViewController"><span class="nav-number">3.2.</span> <span class="nav-text">MPMoviePlayerViewController</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#avPlayer"><span class="nav-number">3.3.</span> <span class="nav-text">AVPlayer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#camera"><span class="nav-number">4.</span> <span class="nav-text">摄像头</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#uiImagePickerController"><span class="nav-number">4.1.</span> <span class="nav-text">UIImagePickerController拍照和视频录制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#avFoundationCamera"><span class="nav-number">4.2.</span> <span class="nav-text">AVFoundation拍照和录制视频</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.2.1.</span> <span class="nav-text">拍照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.2.2.</span> <span class="nav-text">视频录制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#summary"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YCK</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ykcoder"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    motionMiddleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');
      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    };
  });
</script>



  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  
  

</body>
</html>
